<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Typora使用</title>
    <url>/2021/02/02/Typora_usage/</url>
    <content><![CDATA[<p>说来惭愧，刚开始有记录学习和生活的想法的那一段时间，是通过<strong>Word</strong>。需要编辑公式的时候找个简单易上手的公式编辑器找半天，索性也就这样凑合过来了。虽说word功能十分强大，但是写博客的话有点不太对劲。过了大概一年左右，从一个朋友那看到了Typora这个软件，看到界面简洁，而且觉得比记事本稍微好看点，就下载了，只不过是像使用<strong>记事本</strong>一样记录生活。</p>
<p>直到去年疫情期间在家，某天闲得无聊，就开始折腾这个软件了，觉得挺有意思的，开始学习使用。起先发现有些功能涉及到HTML，于是又花了一些时间去大致了解一下HTML。经过多次谷歌、百度之后，掌握了一些常用的功能。这两天搭好了个人博客网站，把几篇之前写的文章都上传到网站上，此篇作为第一篇。</p>
<a id="more"></a>
<p>以下是我自己使用了一段时间Typora之后的总结。由于Typora是Markdown编辑器，所以其是支持HTML的，但是这里仅介绍其常用的几个文本编辑功能，其他的一些HTML语法的部分我了解的也不是很多，此处暂不介绍，以后有时间的话写博客记录一下常用的HTML语法。</p>
<h1 id="1-文章目录的创建"><a href="#1-文章目录的创建" class="headerlink" title="1.文章目录的创建"></a>1.文章目录的创建</h1><p>生成目录：在单独的一行输入[toc]或[TOC]然后回车，即可显示所有标题的目录（并且会根据后面是否继续生成标题而自动更新目录），由于目录一般都在开头，所以一般在文章第一行输入[toc]</p>
<h1 id="2-一些常用的文本渲染"><a href="#2-一些常用的文本渲染" class="headerlink" title="2.一些常用的文本渲染"></a>2.一些常用的文本渲染</h1><p>1.文本居中，通过HTML标签（后面简称标签）：&lt;center&gt;要居中显示的内容&lt;/center&gt;，效果：</p>
<center>要居中显示的内容</center>

<p>2.文本添加删除线：~~这是要添加删除线的内容~~，效果：<del>这是要添加删除线的内容</del></p>
<p>3.文本添加下划线，设置粗体、斜体、粗斜体</p>
<p><u>这是一行带下划线的语句，选中需要添加下划线的文字，再通过Ctrl+U即可为选中的文本添加下划线；同样，也通过Ctrl+U来取消下划线，</u>也可通过标签的&lt;u&gt;添加下划线的内容&lt;/u&gt;</p>
<p>同理，<strong>Ctrl+B设置粗体/取消粗体</strong>，或者：**加粗内容**</p>
<p><em>Ctrl+I设置斜体/取消斜体，如：This is a italics font</em>，或者*斜体内容*</p>
<p><strong><em>Ctrl+I并且Ctrl+B设置加粗斜体，</em></strong>如：<strong><em>This is a bold and italics font</em></strong>，或者***加粗斜体内容***</p>
<p>4.添加分割线，在单独的一行输入三个或三个以上-或者*即可添加分割线，如下</p>
<hr>
<p>5.强制分页输入（在导出的文件中可见效果）：<code>&lt;div style=&quot;page-break-after:always;&quot;&gt;&lt;/div&gt;</code></p>
<h1 id="3-导入图片"><a href="#3-导入图片" class="headerlink" title="3.导入图片"></a>3.导入图片</h1><p>通过 Ctrl+Shift+I （也可输入 ![图片说明](图片路径) 来实现）然后从文件目录中添加图片，如下</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/Penguim.jpg"  /></p>
<p>也可直接拖拽、复制粘贴过来，如下</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/Penguim.jpg" alt="Penguim"></p>
<p><strong>注意</strong>：在所有的Markdown编辑器插入图片，如果是从网上（如从别人博客中）粘贴的图片，尚且不会出现问题；但如果是本地图片，且没有使用图床，只有在自己的电脑查看时才能显示图片，上传md文件到博客时，访问者的终端上并没有该图片，所以会无法显示。此外，由该md文件导出的其他格式文件中也无法显示图片，即显示:<img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210202205311268.png" alt="image-20210202205311268">。因此需要使用图床（即储存图片的服务器），将其上传到服务器中，访问者便能将该图片从服务器中下载缓存到终端上。其实，从网上粘贴的图片也是存在服务器中，访问者访问时终端缓存下载，所以不用图床用户也可以查看。</p>
<h1 id="4-添加超链接"><a href="#4-添加超链接" class="headerlink" title="4.添加超链接"></a>4.添加超链接</h1><p>超链接（Markdown编辑器及导出的文本文档中 Ctrl+左键 访问，导出的html和pdf中直接点击即可访问）</p>
<p>1.&lt;&gt;中输入网址（必须加上<a href="http://），如：">http://），如：</a><a href="http://www.baidu.com">http://www.baidu.com</a></p>
<p>2.快捷键Ctrl+K，或者<code>[不会就百度](http://www.baidu.com)</code>，[]中添加说明内容，()中输入网址，效果：<a href="http://www.baidu.com">不会就百度</a></p>
<h1 id="5-列表和表格"><a href="#5-列表和表格" class="headerlink" title="5.列表和表格"></a>5.列表和表格</h1><h2 id="5-1列表"><a href="#5-1列表" class="headerlink" title="5.1列表"></a>5.1列表</h2><h3 id="5-1-1无序列表"><a href="#5-1-1无序列表" class="headerlink" title="5.1.1无序列表"></a>5.1.1无序列表</h3><p>在单独的一行输入 *+空格，或者 -空格，或者++空格，如下</p>
<ul>
<li>这是用*创建的列表</li>
</ul>
<ul>
<li>这是用-创建的列表</li>
</ul>
<ul>
<li>这是用+创建的列表</li>
</ul>
<ul>
<li>无序列表1</li>
<li>无序列表2（在列表后输入 Tab 即可降级，Shift + Tab 降级，如下）<ul>
<li>无序列表3<ul>
<li>无序列表4<ul>
<li>有序列表5</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>也可使用Ctrl+Shift+]  对选中的文本所在段落生成无序列表</p>
<h3 id="5-1-2有序列表"><a href="#5-1-2有序列表" class="headerlink" title="5.1.2有序列表"></a>5.1.2有序列表</h3><p>在单独的一行输入 数字+.+空格，如下</p>
<ol>
<li>有序列表1</li>
<li>有序列表2（在列表后输入 Tab 即可降级，Shift + Tab 降级，如下）<ol>
<li>有序列表3<ol>
<li>有序列表4<ol>
<li>有序列表5</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>也可使用 Ctrl+Shift+[  对选中的文本所在段落生成有序列表</p>
<h3 id="5-1-3任务列表（不常用）"><a href="#5-1-3任务列表（不常用）" class="headerlink" title="5.1.3任务列表（不常用）"></a>5.1.3任务列表（不常用）</h3><p>在单独一行输入    -空格[空格]空格（在列表后输入 Tab 即可降级，Shift + Tab 降级，如下）</p>
<ul>
<li>[x] 吃饭<ul>
<li>[x] 早上吃啥</li>
<li>[x] 中午吃啥</li>
<li>[x] 晚上吃啥</li>
</ul>
</li>
<li>[x] 睡觉<ul>
<li>[ ] 早上几点起</li>
<li>[x] 晚上几点睡</li>
</ul>
</li>
<li>[ ] 打豆豆<ul>
<li>[x] 我是一个无情的点赞机器</li>
</ul>
</li>
</ul>
<p>由于Hexo的Markdown渲染引擎与Typora不同，所以这里显示不出来，特此截图</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210202212546261.png" alt="image-20210202212546261"></p>
<p>综上，Typora中，列表均可通过Tab和Shift+Tab来对列表进行升级和降级操作</p>
<h2 id="5-2表格"><a href="#5-2表格" class="headerlink" title="5.2表格"></a>5.2表格</h2><ul>
<li>快捷键Ctrl+T，然后设置行列即生成表格</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">姓名</th>
<th style="text-align:center">年龄</th>
<th style="text-align:center">性别</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">张三</td>
<td style="text-align:center">1</td>
<td style="text-align:center">男</td>
</tr>
<tr>
<td style="text-align:center">李四</td>
<td style="text-align:center">2</td>
<td style="text-align:center">女</td>
</tr>
<tr>
<td style="text-align:center">王二麻子</td>
<td style="text-align:center">3</td>
<td style="text-align:center">其他</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">张麻子</td>
<td style="text-align:center">4</td>
<td style="text-align:center">你猜</td>
</tr>
<tr>
<td style="text-align:center">黄鹤</td>
<td style="text-align:center">已跑路，不详</td>
<td style="text-align:center">你再猜</td>
</tr>
</tbody>
</table>
</div>
<p>  在表格中任意位置按下 Ctrl+回车 在该行与下行之间新建一行</p>
<ul>
<li>在单独的一行输入|姓名|年龄|性别|，然后回车，生成表格</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">年龄</th>
<th style="text-align:center">姓名</th>
<th style="text-align:center">性别</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">同上</td>
<td style="text-align:center">同上</td>
<td style="text-align:center">同上</td>
</tr>
</tbody>
</table>
</div>
<h1 id="6-引用"><a href="#6-引用" class="headerlink" title="6.引用"></a>6.引用</h1><p>引用名言，现也用来作为文章的前言，在单独的一行输入 &gt;+空格（或者Ctrl+Shift+Q），如下</p>
<blockquote>
<p>这是第一个引用的第一行</p>
<p>这是第一个引用的第二行</p>
<blockquote>
<p>引用嵌套</p>
<blockquote>
<p>引用再嵌套</p>
</blockquote>
</blockquote>
<p>这是第二个引用中的第一行</p>
<p><em>这是一句斜体</em></p>
<p><strong>这是一句粗体</strong></p>
<p><strong><em>这是一句粗斜体</em></strong></p>
</blockquote>
<h1 id="7-脚注"><a href="#7-脚注" class="headerlink" title="7.脚注"></a>7.脚注</h1><p>类似书中对一些内容作一些详尽的解释，一般把解释写在文章末尾，格式：脚注[^数字]，如下</p>
<p>饮中八仙歌<sup><a href="#fn_1" id="reffn_1">1</a></sup></p>
<p>脚注<sup><a href="#fn_2" id="reffn_2">2</a></sup></p>
<p>注释<sup><a href="#fn_3" id="reffn_3">3</a></sup></p>
<h1 id="8-脚标"><a href="#8-脚标" class="headerlink" title="8.脚标"></a>8.脚标</h1><p>上脚标：<code>x^2^</code> ；下脚标：<code>H~2~O</code></p>
<p>同<code>5.1.3任务列表</code>一样的问题，此处效果无法显示，特此截图：<img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210202225535284.png" alt="image-20210202225535284"></p>
<h1 id="9-行内代码和代码块"><a href="#9-行内代码和代码块" class="headerlink" title="9.行内代码和代码块"></a>9.行内代码和代码块</h1><h2 id="9-1行内代码"><a href="#9-1行内代码" class="headerlink" title="9.1行内代码"></a>9.1行内代码</h2><p>对于简单的一句代码或者需要强调显示的文本（本文中不能显示的格式正是用代码块来显示的），格式：<code>code or text</code>（或者选中内容，Ctrl+Shift+`），如下</p>
<p><code>printf(&quot;笨鸟先飞&quot;);</code>    <code>笨鸟先飞</code>    <code>前文也引用了</code></p>
<h2 id="9-2代码块"><a href="#9-2代码块" class="headerlink" title="9.2代码块"></a>9.2代码块</h2><p>```+编程语言名字（或者Ctrl+Shift+K），如C和JAVA（若没有补加语言说明，则代码不会显示高亮），然后在代码块中输入源码，如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!!!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello, World!!!&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="10-插入公式"><a href="#10-插入公式" class="headerlink" title="10.插入公式"></a>10.插入公式</h1><p>Typora中插入公式是基于LaTex排版系统的，下面仅作了解，具体的一些常用公式的排版见<a href="http://localhost:4000/2021/02/02/formula_in_Typora/">Typora插入公式</a></p>
<h2 id="10-1插入行间公式"><a href="#10-1插入行间公式" class="headerlink" title="10.1插入行间公式"></a>10.1插入行间公式</h2><p>Ctrl+Shift+M 或者 $$+回车，如下</p>
<script type="math/tex; mode=display">
y=x^2\\
\vec{a},\vec{c}\\
\frac{1}{2}\\
\alpha,\beta,\theta,\zeta\\</script><p>这个行间公式是单独显示的，而且默认居中对齐，</p>
<h2 id="10-2插入块间公式"><a href="#10-2插入块间公式" class="headerlink" title="10.2插入块间公式"></a>10.2插入块间公式</h2><p><script type="math/tex">公式</script>，如：$y=x^2$，块间公式是可以在任意位置嵌入的，不能像行间公式那样单独显示</p>
<h1 id="11-表情"><a href="#11-表情" class="headerlink" title="11.表情"></a>11.表情</h1><p>:单词:，仅支持部分表情，具体可查看官方文档</p>
<p>同<code>5.1.3任务列表</code>一样的问题，此处效果无法显示，特此截图：<img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210202215523813.png" alt="image-20210202215523813"></p>
<h1 id="12-脚注解释"><a href="#12-脚注解释" class="headerlink" title="12.脚注解释"></a>12.脚注解释</h1><p>[^数字]:解释</p>
<p>同<code>5.1.3任务列表</code>一样的问题，此处效果无法显示，特此截图：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210202220715217.png" alt="image-20210202220715217"></p>
]]></content>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>码制的一些问题</title>
    <url>/2021/02/02/complement/</url>
    <content><![CDATA[<p>以前上课的时候，经常听见老师将补码的问题，很多门课的老师也会反复说码制之间的转换。但是，+0和-0的问题只是一笔带过。平时也很少遇到这种问题，而我自己又懒，就没有深究。现在想来，懒真的才是万恶之源。最近有空，便仔细想了这个问题，百度之后了解了这个问题。顺便把补码的几种求解方法列举了下来。特此，写篇博客记录下来。</p>
<a id="more"></a>
<h1 id="0和-0的问题"><a href="#0和-0的问题" class="headerlink" title="+0和-0的问题"></a>+0和-0的问题</h1><p>当使用8位二进制来表示-128~127时，</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210202232615462.png" alt="image-20210202232615462"></p>
<p>不难发现，+0和-0的补码是相同的，即2个补码表示同一个数 “0”，因此若不作相应的规定，那么8位补码所能表示的数只有-127~127共255个（注：8位原码范围：-127~-0, +0~127；8位反码范围：同左），而8位本应该能表示256个数，为此，便做了如下规定：</p>
<p><strong>规定：1000 0000（作为补码）表示-128，且-128仅有补码（1000 0000）而没有对应的反码、原码，因此不能根据-128的补码去反推其原码和反码</strong></p>
<h1 id="求解补码的方法"><a href="#求解补码的方法" class="headerlink" title="求解补码的方法"></a>求解补码的方法</h1><p>1.口诀：符号位不变，各位取反，末位加1（有进位则依次进位）</p>
<p>2.将最高位的1和最低位的1之间的数取反，其余不变                 注：若只有一个1，则按照方法1或方法3来</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210202232645268.png" alt="image-20210202232645268"></p>
<p>3.按照补码的定义，负数的补码，定义如下：</p>
<p>​    <img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210202232730990.png" alt="image-20210202232730990"></p>
]]></content>
      <tags>
        <tag>doubt</tag>
      </tags>
  </entry>
  <entry>
    <title>关于字符编码的一些问题</title>
    <url>/2021/03/05/charset/</url>
    <content><![CDATA[<p>第一次遇到乱码问题是在刚买电脑的时候由于Microsoft账户名用中文，导致一些文件夹的名字乱码。之后又在用IDE写代码的时候出现了乱码问题，只知道是字符编码格式不同。但是还是不了解字符集之间的区别。最近想要解决这个疑惑，就在网上搜索咨询了一下，记录下来。但是，由于网上的回答的水平有待提高。甚至百度百科的表述模糊不清：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210305182708179.png" alt="image-20210305182708179">知道的人晓得这是想说：2个字节中的0x0080~0xFFFF，不知道的人还以为0x80~0xFFFF表示2个字节的空间呢！！！真的是令人无语，这种有歧义的表述方式。我甚至刚看到的时候，还以为自己有问题。现在想想真是可笑之极，百度不看也罢！！！以下是我自己找到的较为中肯的解释，有不足之后，待日后发现，及时纠正。</p>
<a id="more"></a>
<h1 id="1-字符编码"><a href="#1-字符编码" class="headerlink" title="1. 字符编码"></a>1. 字符编码</h1><h2 id="1-1-ASCII码"><a href="#1-1-ASCII码" class="headerlink" title="1.1 ASCII码"></a>1.1 ASCII码</h2><p>最开始的时候计算机只在美国用。8位的字节一共可以组合出$2^8$共256种不同的状态。把其中的0x00~0x20的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就做出相应的行为。<br>比如：遇上0x10，终端就换行；遇上0x07，终端就向人们嘟嘟叫；遇上0x1B，打印机就打印反白的字，或者终端就用彩色显示字母。把这些0x20以下的字节状态称为<strong>控制码</strong>。</p>
<p>后来又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号0x7F（后面的128种状态没有用到，就空着了），这样计算机就可以用不同字节来存储英语的文字了。当时使用计算机的人们觉得这种方案可以非常好，可以接受，把这个方案叫做 <strong>ANSI</strong>的<strong>ASCII</strong>编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的<strong>ASCII</strong>方案来保存英文文字。</p>
<p>后来计算机发展越来越广泛，世界各国为了可以在计算机保存他们的文字（有些国家的字符不止美国ASCII码的那些字符，比如希腊字母……），决定采用127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了 最后一个状态255号0xFF。从128到255这之间的字符集被称为<strong>扩展字符集</strong>。至此，1个字节最多也就能表示256种状态了，再也放不下更多的编码了。</p>
<h2 id="1-2-GB2312、GBK、GB18030"><a href="#1-2-GB2312、GBK、GB18030" class="headerlink" title="1.2 GB2312、GBK、GB18030"></a>1.2 GB2312、GBK、GB18030</h2><p>等我国得到计算机时，已经没有可以利用的字节状态来表示汉字，但是此时又有6000多个常用汉字需要保存。于是国人就自主研发，把127号0x7F后面的那些奇异符号直接取消掉。<br>并规定：1个小于127的字符的意义与原来相同（即前128个字符仍是ASCII码），但两个大于127的字符连在一起时，就表示一个汉字。前面的一个字节（称之为高字节），后面一个字节（低字节）。这样我们就可以组合出大约7000多个简体汉字了。碰到极其特殊的情况，还会使用三个字节来表示一个汉字。在这种编码里，我们还把数学符号、罗马希腊的字母、日文的假名都编进去了，还把ASCII码所表示的128个字符重新编了两个字节长的编码，这就是常说的<strong>全角字符</strong>，而原来没有做改动的0x00~0x7F之间的字符就叫<strong>半角字符</strong>。<br>中国人民看到这样很不错，于是就把这种编码方案叫做<strong>GB2312</strong>。<strong>GB2312</strong> 是对 <strong>ASCII</strong> 的中文扩展。<br>但是中国的汉字太多了，后来还是不够用，于是干脆不再要求低字节一定是127号之后的，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。扩展之后的编码方案被称为 <strong>GBK</strong> 标准，GBK 包括了GB2312的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，<strong>GBK</strong> 扩成了<strong>GB18030</strong>。从此之后，中国的所有字符都能在计算机中表示了。</p>
<h2 id="1-3-Unicode码"><a href="#1-3-Unicode码" class="headerlink" title="1.3 Unicode码"></a>1.3 Unicode码</h2><p>因为当时各个国家都像中国这样，有一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码。当时的中国人想让电脑显示汉字，就必须装上一个<strong>汉字系统</strong>以采用上文提到过的编码格式专门用来处理汉字的显示、输入的问题，其他国家亦是如此。如果装错了字符系统，就会乱码，这在当时成了一个让人们头疼的问题。<br>就在这时，<strong>ISO</strong>（International Organization for Standardization，国际标谁化组织）决定着手解决这个问题。他们采用的方法很简单：废除所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称UCS, 俗称<strong>Unicode</strong>。</p>
<p>目前最常用的Unicode编码是UCS-16编码，用2个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。对于ASCII码的那些<strong>半角字符</strong>，Unicode保持其原编码不变，只是将其长度由原来的8位扩展为16位（只用低8位，高8位恒为0），而其他文化和语言的字符则全部重新统一编码。由于半角英文符号只用到低8位，高 8位永远是0，如半角英文大写字母A用Unicode码是<code>0x0065</code>。因此这种大气的方案在保存英文文本时会多浪费一倍的空间。<br>但是，Unicode码在制订时没有考虑与任何一种现有的编码方案保持兼容，所有现有的编码与Unicode在汉字的内码编排上完全是不一样的，没有一种简单的算术方法可以把文本内容从Unicode编码和另一种编码进行转换，因此这种转换必须通过查表来进行。</p>
<h2 id="1-4-UTF-8"><a href="#1-4-UTF-8" class="headerlink" title="1.4 UTF-8"></a>1.4 UTF-8</h2><p>Unicode来到时，一起到来的还有计算机网络的兴起，Unicode如何在网络上传输也是一个必须考虑的问题，于是众多面向传输的UTF（UCS Transfer Format，UCS传输标准）出现了。顾名思义，<strong>UTF-8</strong>就是每次8个位传输数据，而 <strong>UTF-16</strong>就是每次16个位。<strong>为了传输时的可靠性，从Unicode到UTF时并不是直接的对应，而是要过一些算法和规则来转换，</strong>目前常用的是<strong>UTF-8</strong>编码。<br><strong>UTF-8</strong>编码把一个Unicode字符根据不同的数字大小编码成1-6个字节。其中，英文字母被编码成1个字节，汉字被编码成3个字节，极其生僻的字符被编码成4-6个字节。如果要传输的文本包含大量英文字符，用UTF-8编码就能节省空间。下面举一个例子：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">ASCII</th>
<th style="text-align:left">Unicode</th>
<th style="text-align:left">UTF-8</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">A</td>
<td style="text-align:left">01000001</td>
<td style="text-align:left">00000000 01000001</td>
<td style="text-align:left">01000001</td>
</tr>
<tr>
<td style="text-align:left">中</td>
<td style="text-align:left">x</td>
<td style="text-align:left">01001110 00101101</td>
<td style="text-align:left">11100100 10111000 10101101</td>
</tr>
</tbody>
</table>
</div>
<h2 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h2><p>简单概括为以下几点：<br>1.中国人民通过对ASCII编码的中文扩充改造，产生了GB2312编码，可以表示6000多个常用汉字；<br>2.汉字实在是太多了，包括繁体和各种中文字符，于是产生了GBK编码，它包括了GB2312中的编码，同时扩充了很多；<br>3.中国是个多民族国家，各个民族几乎都有自己独立的语言系统，为了表示那些字符，继续把 GBK 编码扩充为 GB18030 编码；<br>4.每个国家都像中国一样，把自己的语言进行编码，于是出现了各种各样的编码，如果不安装相应编码，就会出现乱码；<br>5.ISO组织制定了一种编码Unicode，这种编码非常大，可以容纳世界上任何一个文字和标志，所以只要电脑上有Unicode这种编码系统，无论是全球哪种文字，保存成Unicode编码就可以被其他电脑正常解释；<br>6.Unicode 在网络传输中，出现了<strong>两个标准UTF-8和UTF-16</strong>，分别每次传输 8个位和 16个位。</p>
<h2 id="1-6-问题"><a href="#1-6-问题" class="headerlink" title="1.6 问题"></a>1.6 问题</h2><p>既然UTF-8能保存那么多文字、符号，为什么国内还有很多地方使用GBK等编码？<br>答：因为UTF-8编码体积比较大，占电脑空间比较多，如果面向的使用人群绝大部分都是中国人，用GBK等编码也可以，还能节省硬盘空间。目前，硬盘价格都不再像以前那样贵得要死，都是是可接受的，所以现在的网页统一都使用<strong>UTF-8</strong>编码。</p>
<h1 id="2-计算机系统通用的字符编码工作方式"><a href="#2-计算机系统通用的字符编码工作方式" class="headerlink" title="2. 计算机系统通用的字符编码工作方式"></a>2. 计算机系统通用的字符编码工作方式</h1><p>在计算机内存中，统一使用<code>Unicode</code>编码，当需要保存到硬盘或者需要传输的时候，就转换为<code>UTF-8</code>编码。即：<br>用记事本编辑的时候，从硬盘中的文件读取的<code>UTF-8</code>字符被转换为<code>Unicode</code>字符加载到内存里，编辑完成后，保存的时候再把<code>Unicode</code>转换为<code>UTF-8</code>保存到文件：</p>
<center><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/0.png"></center>

<p>浏览网页的时候，服务器会把动态生成的<code>Unicode</code>内容转换为<code>UTF-8</code>再传输到浏览器：</p>
<center><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/01.png"></center>

<p>所以很多网页的源码种会有类似<code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code>的信息，表示该网页正是用的<code>UTF-8</code>编码。由于<code>ASCII</code>码是最开始的字符编码格式，其他所有的编码格式都是基于<code>ASCII</code>码的扩展，所以所有的编码都能够兼容<code>ASCII</code>码。</p>
]]></content>
      <tags>
        <tag>doubt</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora插入公式</title>
    <url>/2021/02/02/formula_in_Typora/</url>
    <content><![CDATA[<p>Typora中插入公式是基于LaTex排版系统的。关于LaTex，因为并不是所有的人都懂得专业的书籍及论文的排版，而这些排版的知识的学习成本极高。LaTex相较其而言，学习成本较低，可以让一些排版和程序设计的知识也可以能在几天、甚至几小时内生成很多具有书籍质量的印刷品。</p>
<p>对于生成复杂表格和数学公式，这一点表现得尤为突出。许多的公式编辑器也陆续支持LaTex，用途十分广泛。</p>
<p>关于LaTex的具体介绍，<a href="https://baike.baidu.com/item/LaTeX/1212106?fr=aladdin">详见百科</a>。以下介绍常用的公式排版，详细的全部公式排版见<a href="https://latexlive.com/help">LaTex帮助文档</a>。关于书籍以及论文的排版此处不讨论。</p>
<a id="more"></a>
<p>以下所有的公式都是基于    <img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210203212848586.png" alt="image-20210203212848586">    或者    <img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210203212858506.png" alt="image-20210203212858506">    的形式，因为Markdown语法中插入公式就是通过<code>美元符$</code>来实现的</p>
<h1 id="公式中的转义字符’-‘"><a href="#公式中的转义字符’-‘" class="headerlink" title="公式中的转义字符’\‘"></a>公式中的转义字符’\‘</h1><p>转义字符，和编程语言一样，是用来通过一些易记忆的命令来使得其能够展示符号效果</p>
<h2 id="1-一些常见的符号"><a href="#1-一些常见的符号" class="headerlink" title="1.一些常见的符号"></a>1.一些常见的符号</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">显示</th>
<th style="text-align:center">命令</th>
<th style="text-align:center">显示</th>
<th style="text-align:center">命令</th>
<th style="text-align:center">显示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\space</td>
<td style="text-align:center">空格</td>
<td style="text-align:center">\sum</td>
<td style="text-align:center">$\sum$</td>
<td style="text-align:center">\oiint</td>
<td style="text-align:center"><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210203205118408.png" alt="image-20210203205118408"></td>
</tr>
<tr>
<td style="text-align:center">\\</td>
<td style="text-align:center">换行</td>
<td style="text-align:center">\prod</td>
<td style="text-align:center">$\prod$</td>
<td style="text-align:center">\oiiint</td>
<td style="text-align:center"><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210203205137688.png" alt="image-20210203205137688"></td>
</tr>
<tr>
<td style="text-align:center">\and,\or,\not</td>
<td style="text-align:center"><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210203210252892.png" alt="image-20210203210252892"></td>
<td style="text-align:center">\partial</td>
<td style="text-align:center">$\partial$</td>
<td style="text-align:center">\%</td>
<td style="text-align:center">$\%$</td>
</tr>
<tr>
<td style="text-align:center">\exist</td>
<td style="text-align:center"><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210203205930278.png" alt="image-20210203205930278"></td>
<td style="text-align:center">\rm{d}</td>
<td style="text-align:center">$\rm{d}$</td>
<td style="text-align:center">\approx</td>
<td style="text-align:center">$\approx$</td>
</tr>
<tr>
<td style="text-align:center">\to</td>
<td style="text-align:center">$\to$</td>
<td style="text-align:center">a,b,\rm{a},\rm{b}···</td>
<td style="text-align:center">$a,b,\rm{a},\rm{b},\cdots$</td>
<td style="text-align:center">\leq</td>
<td style="text-align:center">$\leq$</td>
</tr>
<tr>
<td style="text-align:center">\neq</td>
<td style="text-align:center">$\neq$</td>
<td style="text-align:center">\nabla</td>
<td style="text-align:center">$\nabla$</td>
<td style="text-align:center">\geq</td>
<td style="text-align:center">$\geq$</td>
</tr>
<tr>
<td style="text-align:center">\infty,\+infty,\infty</td>
<td style="text-align:center">$\infty,+\infty,-\infty$</td>
<td style="text-align:center">\Delta</td>
<td style="text-align:center">$\Delta$</td>
<td style="text-align:center">\cdot</td>
<td style="text-align:center">$\cdot$</td>
</tr>
<tr>
<td style="text-align:center">\lim</td>
<td style="text-align:center">$\lim$</td>
<td style="text-align:center">\triangle</td>
<td style="text-align:center">$\triangle$</td>
<td style="text-align:center">\times</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">\max</td>
<td style="text-align:center">$\max$</td>
<td style="text-align:center">\int,\iint,\iiint</td>
<td style="text-align:center">$\int,\iint,\iiint$</td>
<td style="text-align:center">\div</td>
<td style="text-align:center">$\div$</td>
</tr>
<tr>
<td style="text-align:center">\min</td>
<td style="text-align:center">$\min$</td>
<td style="text-align:center">\oint</td>
<td style="text-align:center">$\oint$</td>
<td style="text-align:center">\exp</td>
<td style="text-align:center">$\exp$</td>
</tr>
<tr>
<td style="text-align:center">\overline{Q}</td>
<td style="text-align:center">$\overline{Q}$</td>
<td style="text-align:center">\dots</td>
<td style="text-align:center">$\dots$</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">\underline{Q}</td>
<td style="text-align:center">$\underline{Q}$</td>
<td style="text-align:center">\cdots</td>
<td style="text-align:center">$\cdots$</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p>此处只是列举一些符号，常用的公式符号下面一一展开。并且由于渲染引擎的问题，本文中一些公式使用了截图来显示效果。</p>
<h2 id="2-希腊字母"><a href="#2-希腊字母" class="headerlink" title="2.希腊字母"></a>2.希腊字母</h2><p>\字母发音，如下</p>
<script type="math/tex; mode=display">
\alpha,\beta,\gamma</script><p>附上一张希腊字母表，如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">小写</th>
<th style="text-align:left">LaTeX</th>
<th style="text-align:left">读音</th>
<th style="text-align:center">序号</th>
<th style="text-align:center">大写</th>
<th style="text-align:left">LaTeX</th>
<th style="text-align:left">读音</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">α</td>
<td style="text-align:left">\alpha</td>
<td style="text-align:left">/ˈælfə/</td>
<td style="text-align:center">31</td>
<td style="text-align:center">Γ</td>
<td style="text-align:left">\Gamma</td>
<td style="text-align:left">/ˈɡæmə/</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">β</td>
<td style="text-align:left">\beta</td>
<td style="text-align:left">/ˈbiːtə/, US: /ˈbeɪtə/</td>
<td style="text-align:center">32</td>
<td style="text-align:center">Δ</td>
<td style="text-align:left">\Delta</td>
<td style="text-align:left">/ˈdɛltə/</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">γ</td>
<td style="text-align:left">\gamma</td>
<td style="text-align:left">/ˈɡæmə/</td>
<td style="text-align:center">33</td>
<td style="text-align:center">Θ</td>
<td style="text-align:left">\Theta</td>
<td style="text-align:left">/ˈθiːtə/</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">δ</td>
<td style="text-align:left">\delta</td>
<td style="text-align:left">/ˈdɛltə/</td>
<td style="text-align:center">34</td>
<td style="text-align:center">Λ</td>
<td style="text-align:left">\Lambda</td>
<td style="text-align:left">/ˈlæmdə/</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">ϵ</td>
<td style="text-align:left">\epsilon</td>
<td style="text-align:left">/ˈɛpsɪlɒn/</td>
<td style="text-align:center">35</td>
<td style="text-align:center">Ξ</td>
<td style="text-align:left">\Xi</td>
<td style="text-align:left">/zaɪ, ksaɪ/</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">ε</td>
<td style="text-align:left">\varepsilon</td>
<td style="text-align:left">/ˈɛpsɪlɒn/</td>
<td style="text-align:center">36</td>
<td style="text-align:center">Π</td>
<td style="text-align:left">\Pi</td>
<td style="text-align:left">/paɪ/</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">ζ</td>
<td style="text-align:left">\zeta</td>
<td style="text-align:left">/ˈzeɪtə/</td>
<td style="text-align:center">37</td>
<td style="text-align:center">Σ</td>
<td style="text-align:left">\Sigma</td>
<td style="text-align:left">/ˈsɪɡmə/</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">η</td>
<td style="text-align:left">\eta</td>
<td style="text-align:left">/ˈeɪtə/</td>
<td style="text-align:center">38</td>
<td style="text-align:center">Υ</td>
<td style="text-align:left">\Upsilon</td>
<td style="text-align:left">/ˈʌpsɪlɒn/</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">θ</td>
<td style="text-align:left">\theta</td>
<td style="text-align:left">/ˈθiːtə/</td>
<td style="text-align:center">39</td>
<td style="text-align:center">Φ</td>
<td style="text-align:left">\Phi</td>
<td style="text-align:left">/faɪ/</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">ϑ</td>
<td style="text-align:left">\vartheta</td>
<td style="text-align:left">/ˈθiːtə/</td>
<td style="text-align:center">40</td>
<td style="text-align:center">Ψ</td>
<td style="text-align:left">\Psi</td>
<td style="text-align:left">/psaɪ/</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">ι</td>
<td style="text-align:left">\iota</td>
<td style="text-align:left">/aɪˈoʊtə/</td>
<td style="text-align:center">41</td>
<td style="text-align:center">Ω</td>
<td style="text-align:left">\Omega</td>
<td style="text-align:left">/oʊˈmeɪɡə/</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">κ</td>
<td style="text-align:left">\kappa</td>
<td style="text-align:left">/ˈkæpə/</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">λ</td>
<td style="text-align:left">\lambda</td>
<td style="text-align:left">/ˈlæmdə/</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">μ</td>
<td style="text-align:left">\mu</td>
<td style="text-align:left">/mjuː/</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">ν</td>
<td style="text-align:left">\nu</td>
<td style="text-align:left">/njuː/</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">ξ</td>
<td style="text-align:left">\xi</td>
<td style="text-align:left">/zaɪ, ksaɪ/</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center">o</td>
<td style="text-align:left">o</td>
<td style="text-align:left">/ˈɒmɪkrɒn/</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">18</td>
<td style="text-align:center">π</td>
<td style="text-align:left">\pi</td>
<td style="text-align:left">/paɪ/</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td style="text-align:center">ϖ</td>
<td style="text-align:left">\varpi</td>
<td style="text-align:left">/paɪ/</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center">ρ</td>
<td style="text-align:left">\rho</td>
<td style="text-align:left">/roʊ/</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">21</td>
<td style="text-align:center">ϱ</td>
<td style="text-align:left">\varrho</td>
<td style="text-align:left">/roʊ/</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">22</td>
<td style="text-align:center">σ</td>
<td style="text-align:left">\sigma</td>
<td style="text-align:left">/ˈsɪɡmə/</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">23</td>
<td style="text-align:center">ς</td>
<td style="text-align:left">\varsigma</td>
<td style="text-align:left">/ˈsɪɡmə/</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">24</td>
<td style="text-align:center">τ</td>
<td style="text-align:left">\tau</td>
<td style="text-align:left">/taʊ, tɔː/</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">25</td>
<td style="text-align:center">υ</td>
<td style="text-align:left">\upsilon</td>
<td style="text-align:left">/ˈʌpsɪlɒn/</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">26</td>
<td style="text-align:center">ϕ</td>
<td style="text-align:left">\phi</td>
<td style="text-align:left">/faɪ/</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">27</td>
<td style="text-align:center">φ</td>
<td style="text-align:left">\varphi</td>
<td style="text-align:left">/faɪ/</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">28</td>
<td style="text-align:center">χ</td>
<td style="text-align:left">\chi</td>
<td style="text-align:left">/kaɪ/</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">29</td>
<td style="text-align:center">ψ</td>
<td style="text-align:left">\psi</td>
<td style="text-align:left">/psaɪ/</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">30</td>
<td style="text-align:center">ω</td>
<td style="text-align:left">\omega</td>
<td style="text-align:left">/oʊˈmeɪɡə/</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<h1 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h1><h2 id="1-根号"><a href="#1-根号" class="headerlink" title="1.根号"></a>1.根号</h2><p>格式：<code>\sqrt3</code>，如：$\sqrt3$；若开多次方：\sqrt[5]3，如：$\sqrt[5]3$</p>
<h2 id="2-分式"><a href="#2-分式" class="headerlink" title="2.分式"></a>2.分式</h2><p><code>\frac&#123;3x&#125;&#123;2y&#125;</code>，如：$\frac{3x}{2}$</p>
<h2 id="3-上标和下标"><a href="#3-上标和下标" class="headerlink" title="3.上标和下标"></a>3.上标和下标</h2><p>此处以右上下标为例，正上下标到下一标题中的极限中统一讨论</p>
<p>右上标：<code>x^t</code>，如：$x^t$；右下标：<code>x_i</code>，如：$x_i$</p>
<p>当上下标多于一个字母或符号时，需要用{}将其括起来，即：<code>x^&#123;\alpha t&#125;,x_&#123;i1&#125;</code>，如：$x^{\alpha t},x_{i1}$</p>
<p>上下标组合：<code>a_1^2 + a_2^2 = a_3^2</code>，如：$ a_1^2 + a_2^2 = a_3^2 $</p>
<h2 id="4-极限"><a href="#4-极限" class="headerlink" title="4.极限"></a>4.极限</h2><p>1.插入行间公式：</p>
<p>${\lim_{x \to 0^+}}$</p>
<p>2.插入块间公式：</p>
<script type="math/tex; mode=display">
{\lim_{x \to 0^+}}</script><p>3.上述插入的行间公式和块间公式是一模一样的。但是由上述区别可以看出，在Typora中，若插入行间公式，则上下标显示在右下角和右上角；若插入块间公式，则上下标显示在正下方和正上方</p>
<p>4.若要移动行间和快件公式的上下标的位置，则在该字符 lim 与下标符 _ 中间添加： </p>
<ul>
<li><p>若要将行间公式的上下标强制移动到上下方（一般用于在行间公式中显示上下标），则添加<code>\limits</code>，如下</p>
<p>​    $\lim\limits_{x \to 0^+}$</p>
</li>
<li><p>若要将块间公式的上下标强制移动到右上下放，则添加 <code>\nolimits</code>（一般用于在行块间公式中显示右上下标），如下：</p>
</li>
</ul>
<script type="math/tex; mode=display">
{\lim \nolimits_{x \to 0^+}}</script><p>5.对于数学符号，要添加上下标，直接操作即可；对于非数学符号的普通符号如Math，若要对其添加上下标（一般是下标）则需要利用<code>\mathop&#123;Math&#125;</code>先将其转化为数学符号，再进行添加下标的操作：$\mathop{Math} \limits_{a \to \infty}$</p>
<p>6.几个经典极限如下</p>
<script type="math/tex; mode=display">
{\lim_{x \to 0}\frac{sinx}{x}=1}\\
{\lim_{x \to \infty}(1+\frac{1}{x})^x=e}\\
{\lim_{x \to 0}(1 + x)^{\frac{1}{x}}=e}\\</script><h2 id="5-积分"><a href="#5-积分" class="headerlink" title="5.积分"></a>5.积分</h2><p>格式：<code>\int_1^&#123;+ \infty&#125;</code>，如：$\int_1^{+ \infty}$</p>
<p>多重积分：<code>\iiint_1^&#123;n&#125;</code>，如：$\iiint_1^{n}$</p>
<p>闭合曲线积分：<code>\oint \limits_C</code>，如：$\oint \limits_C$</p>
<p>多重闭合曲积分：<code>\oiiint \limits_&#123;l&#125;</code>，如：<img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210203214856817.png" alt="image-20210203214856817"></p>
<h2 id="6-方程组、行列式、矩阵"><a href="#6-方程组、行列式、矩阵" class="headerlink" title="6.方程组、行列式、矩阵"></a>6.方程组、行列式、矩阵</h2><script type="math/tex; mode=display">
方程组：
\left\{
    \begin{array}{}
        a_1x+b_1y+c_1z=d_1\\
        a_2x+b_2y+c_2z=d_2\\
        a_3x+b_3y+c_3z=d_3
    \end{array}
\right.
\\
行列式：
\begin{vmatrix}
    1 &    2    & 3\\ 
    4 &    5    & 6\\ 
    7 &    8    & 9
\end{vmatrix}\\
矩阵：
\begin{matrix} {}
    1 &    2    & 3\\ 
    4 &    5    & 6\\ 
    7 &    8    & 9
\end{matrix}
\ or 
\begin{bmatrix} {}
    1 &    2    & 3\\ 
    4 &    5    & 6\\ 
    7 &    8    & 9
\end{bmatrix}
\ or 
\left(
\begin{array}{}
    1 &    2    & 3\\ 
    4 &    5    & 6\\ 
    7 &    8    & 9
\end{array}
\right)</script><h1 id="几个重要的公式"><a href="#几个重要的公式" class="headerlink" title="几个重要的公式"></a>几个重要的公式</h1><h2 id="1-双曲函数"><a href="#1-双曲函数" class="headerlink" title="1.双曲函数"></a>1.双曲函数</h2><script type="math/tex; mode=display">
双曲函数
\begin{cases}
双曲正弦函数：\sinh x = \frac{e^x - e^{-x}}{2}\\
双曲余弦函数：\cosh x = \frac{e^x + e^{-x}}{2}
\end{cases}，
满足：\cosh^2 x - \sinh^2 x =1</script><h2 id="2-欧拉公式"><a href="#2-欧拉公式" class="headerlink" title="2.欧拉公式"></a>2.欧拉公式</h2><script type="math/tex; mode=display">
欧拉公式
\begin{cases}
e^{ix} = \cos x + i\sin x \\
\sin x = \frac{e^{ix}-e^{-ix}}{2i}\\
\cos x = \frac{e^{ix}+e^{-ix}}{2}\\
\end{cases}\\
对比上述双曲函数，不难发现，在复数域，满足
\begin{cases}
\sin ix = -i\sinh x\\
\cos ix = \cosh x
\end{cases}</script><h2 id="3-积化和差、和差化积"><a href="#3-积化和差、和差化积" class="headerlink" title="3.积化和差、和差化积"></a>3.积化和差、和差化积</h2><script type="math/tex; mode=display">
积化和差公式
\begin{cases}
\sin x \cos y = \frac{1}{2}[\sin(x+y)+\sin(x-y)]\\
\cos x \cos y = \frac{1}{2}[\cos(x+y)+\cos(x-y)]\\
\sin x \sin y = \frac{1}{2}[\cos(x-y)-\cos(x+y)]
\end{cases}</script><script type="math/tex; mode=display">
和差化积公式
\begin{cases}
\sin x \pm \sin y = 2\sin\frac{x \pm y}{2} \cos\frac{x \mp y}{2}\\
\cos x + \cos y = 2\cos\frac{x + y}{2} \cos\frac{x - y}{2}\\
\cos x - \cos y = -2\sin\frac{x + y}{2} \sin\frac{x - y}{2}
\end{cases}</script><h2 id="4-正切函数"><a href="#4-正切函数" class="headerlink" title="4.正切函数"></a>4.正切函数</h2><script type="math/tex; mode=display">
\begin{cases}
\tan(x\pm y) = \frac{\tan x\pm\tan y}{1\mp\tan x\tan y}\\
\tan 2x = \frac{2\tan x}{1- \tan^2x}\\
\tan^2\frac{x}{2} = \frac{1-\cos x}{1+\cos x}
\end{cases}</script><h2 id="5-万能公式"><a href="#5-万能公式" class="headerlink" title="5.万能公式"></a>5.万能公式</h2><script type="math/tex; mode=display">
万能公式
\begin{cases}
\sin x = \frac{2\tan x}{1-\tan^2 x}\\
\cos x = \frac{1- \tan^2 \frac{x}{2}}{1+\tan^2 \frac{x}{2}}\\
\tan x = \frac{2\tan\frac{x}{2}}{1-\tan^2\frac{x}{2}}
\end{cases}</script><h2 id="6-三倍角公式"><a href="#6-三倍角公式" class="headerlink" title="6.三倍角公式"></a>6.三倍角公式</h2><script type="math/tex; mode=display">
三倍角公式
\begin{cases}
\sin 3x = 3\sin x - 4\sin^3 x\\
\cos 3x = 4\cos^3 x - 3\cos x
\end{cases}</script>]]></content>
      <tags>
        <tag>Typora</tag>
        <tag>LaTex</tag>
      </tags>
  </entry>
  <entry>
    <title>自然底数e的由来</title>
    <url>/2021/02/02/origin_of_e/</url>
    <content><![CDATA[<p>与圆周率$\pi$一样，自然底数e是一个常数。然而自从知道e开始，就只记得其大致的值为2.71828182845…，却不知其从何而来，这个数有什么意义。</p>
<p>直到一天我在图书馆无意中翻看到一本关于物理学史的书时，发现上面大致介绍了一下这个常数的由来，特此写一篇博客记录。</p>
<a id="more"></a>
<p>首先，e 这个表示自然底数的符号是由瑞士数学和物理学家Leonhard Euler(莱昂哈德·欧拉)命名的，取的正是Euler的首字母“ <img src="https://www.zhihu.com/equation?tex=e" alt="[公式]"> ”</p>
<p>但实际上，第一个发现这个常数的，并非欧拉本人，而是<strong>雅可比·伯努利</strong>（Jacob Bernoulli）（提出雅各比公式的那位），伯努利家族是17〜18世纪瑞士的一个赫赫有名的家族，其中出了很多著名的数理科学家，雅可比·伯努利是<strong>约翰·伯努利</strong>（Johann Bernoulli）的哥哥，而约翰·伯努利则是欧拉的数学老师。</p>
<p>步入正题。我们知道，很多细菌是通过二分裂进行繁殖的，假设某种细菌1天会分裂1次，也就是 1 个增长周期为1天，这意味着：<strong>每一天，细菌的总数量都是前一天的两倍</strong>。<br>不难得出：1个细菌分裂$x$天后，细菌总数为$2^x$，那么$K$个细菌分裂$x$天后细菌总数为$Q=K\cdot2^x$</p>
<p>如果将 “<strong>分裂</strong>”或“<strong>翻倍</strong>”换一种更文艺的说法，也可以说是：“<strong>增长率为$100\%$</strong> ”。也就是说，可以将上式写为：$(1+100\%)^x$，然而当增长率不是100%，而是50%、25%之类的时候，则需要将上式的100%更换即可。如此一来，便可得到适用于其他类似增长事物的普适的公式：</p>
<script type="math/tex; mode=display">
Q=(1+r)^x</script><p>这个公式的数学内涵是：一个增长周期内的增长率为 $r$ ，在增长了 $x$ 个周期之后，总数也将为初始量的 $Q$ 倍。</p>
<p>以上为指数增长的一个简单实例，下面来看看雅可比·伯努利的发现：</p>
<p>假如你有1元钱存在银行中，而银行的利率飙升到了100%（理想情况，姑且认为是严重的通货膨胀吧），若银行一年付一次利息，则一年后你可以拿到1元的本金和1元的利息，总共2元。</p>
<p>现在银行的年利率不变，但是为了招揽客户，推出每半年就付一次利息（年利率还是100%，只不过一半时间内付一半的利息）的政策，那么在六个月后，你就能拿到1元的本金和0.5元的利息，总共1.5元，若不取出，而是继续存入银行中产生利息（俗称利滚利，专业术语称<strong>复利</strong>），那么再过六个月，存款将为2.25元。可用如下公式模拟：</p>
<script type="math/tex; mode=display">
Q=(1+\frac{100\%}{2})^2</script><p>继续，假设现在银行为了和其他银行抢生意，短期不想赚钱了，每四个月就付一次利息！而机智的你依然不取出而是继续存，与半年结算一次利息类似：即，每个结算周期为四个月，每四个月的利率是$\frac{100\%}{3}$，用如下公式模拟：</p>
<script type="math/tex; mode=display">
Q=(1+\frac{100\%}{3})^3\approx2.37037</script><p>不难发现，年利率虽然没变，但是随着每年利息交付次数的增加（按照时间每隔一段时间就付之以相对应时间占比的利率，如半年50%，四个月33.33%，三个月25%等），能从银行拿到的钱也在增加。随着交付次数的不断增加，当其趋于无穷时（即相当于每时每刻都在交付利息），经过不断计算发现，其最终的值趋于一个常数2.71828182845…，将其用字母 e 来定义，即得以下极限</p>
<script type="math/tex; mode=display">
e=\lim_{n \to \infty}(1+\frac{1}{n})^n\\
此处的\infty默认为+\infty</script><p>然而，实际上银行的利率永远也不会超过100%（银行不做慈善），此外，有些事物的增长率是超过100%甚至是远超的。若将100%用变量x代替，便可得到满足所有自然增长事物的增长规律。以下是推导过程：</p>
<script type="math/tex; mode=display">
e=\lim_{n \to \infty}(1+\frac{1}{n})^n=\lim_{n \to \infty}(1+\frac{1}{\frac{n}{x}})^\frac{n}{x}=\lim_{n \to \infty}(1+\frac{x}{n})^\frac{n}{x}\\
不难发现，e^x=\lim_{n \to \infty}((1+\frac{x}{n})^\frac{n}{x})^x\\
\qquad\qquad\ \ \ =\lim_{n \to \infty}(1+\frac{x}{n})^n</script><p>由此便将式中的100%用 x 代替，便可表征所有自然增长的规律（ x代表增长率，既可能大于1，也可能小于1，甚至可能小于0（亏损、减少））</p>
<p>有了自然之数，便有了其他底数为底的指数函数</p>
]]></content>
      <tags>
        <tag>doubt</tag>
      </tags>
  </entry>
  <entry>
    <title>将进酒</title>
    <url>/2021/02/03/poem1/</url>
    <content><![CDATA[<p>终于把博客网站部署好了！！！也算有了自己的网站，特此背诵一首李白的《将进酒》留作以后纪念😄</p>
<a id="more"></a>
<center>将进酒</center>

<p><center>君不见，黄河之水天上来，奔流到海不复回。</p>
<p><center>君不见，高堂明镜悲白发，朝如青丝暮成雪。</p>
<p><center>人生得意须尽欢，莫使金樽空对月。</p>
<p><center>天生我才必有用，千金散尽还复来。</p>
<p><center>烹羊宰牛且为乐，会须一饮三百杯。</p>
<p><center>岑夫子，丹丘生，将进酒，杯莫停。</p>
<p><center>与君歌一曲，请君为我倾耳听。</p>
<p><center>钟鼓馔玉不足贵，但愿长醉不复醒。</p>
<p><center>古来圣贤皆寂寞 ，惟有饮者留其名。</p>
<p><center>陈王昔时宴平乐，斗酒十恣欢谑。</p>
<p><center>主人何为言少钱，径须沽取对君酌。</p>
<p><center>五花马、千金裘，呼儿将出换美酒，与尔同销万古愁。</p>
]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title>这个博客能够带走和留下什么</title>
    <url>/2021/02/02/%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2%E8%83%BD%E5%A4%9F%E5%B8%A6%E8%B5%B0%E5%92%8C%E7%95%99%E4%B8%8B%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p><center>1.从我自己的角度，看看<b>社会和世界的样子</b></center></p>

<p><center>2.从我的博客中，看到自己<b>看待问题的思路</b></center></p>

<p><center>3.记录生活的点点滴滴，<b>热爱生活</b></center></p>

<a id="more"></a>
<p>我为什么写博客？<br>1.记录以后可能会用得到的东西（教程，心得，总结等）<br>2.记录每天的生活和想法，热爱生活<br>3.供多年以后追念</p>
]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言基础</title>
    <url>/2021/02/08/C_progarmming/</url>
    <content><![CDATA[<p>在刚学C语言的时候就是奔着考试去的，直到后面学了计算机的工作原理之后才发现底层原理是如此地重要，便又重新将C慢慢捡了回来。本来刚建好博客的时候应该把文章发布的，但是最近事情较多，就没有将文章发布到自己的博客网站上。今天有空就发布了。</p>
<p>以下内容较为基础，且仅涉及我自己容易忘记的重要知识点，供以后再次忘记时查阅。此篇博客未完待续……</p>
<a id="more"></a>
<h1 id="Switch语句执行机制"><a href="#Switch语句执行机制" class="headerlink" title="Switch语句执行机制"></a>Switch语句执行机制</h1><p><strong>1. 首先，判断;</strong></p>
<ul>
<li>在所有case关键字后面的值中，查找与“switch(a)”中的“a”一致的值。如果case语句与case语句之间有default语句，直接跳过default语句</li>
</ul>
<p><strong>2. 然后，执行;</strong></p>
<ul>
<li>若有与之匹配相同的值，则执行该case所属的那条语句</li>
<li>若没有与之匹配相同的值，则执行该default所属的那条语句</li>
</ul>
<p><strong>3. 最后，结束;</strong></p>
<ul>
<li>若被执行的case语句或者default语句后面没有语句了（即，到了switch语句末尾）,则在执行该语句之后，跳出switch语句，结束；</li>
<li>若后面仍有语句，则在执行完该语句之后，对后面的语句不加以判断（default语句也是，不加以判断），直接按顺序执行，直到switch语句末尾，结束；</li>
</ul>
<p>所以一般会在每个case后面增加一个break语句以跳出switch，从而避免在完成任务后不加判断地执行其后面的语句;</p>
<p>代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//int a = 2;</span></span><br><span class="line">      <span class="comment">//int a = 3;</span></span><br><span class="line">	<span class="keyword">switch</span> (a) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;2\n&quot;</span>);</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;3\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;没有找到对应的值，执行deafault语句\n&quot;</span>);</span><br><span class="line">	<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;4\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果如下：</p>
<ul>
<li>当a=1时<br><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/2229104-20210109210221394-821136187.png" alt=""></li>
<li>当a=2时<br><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/2229104-20210109210450073-968059575.png" alt=""></li>
<li>当a=3时<br><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/2229104-20210109210613507-1532583958.png" alt=""></li>
</ul>
<h1 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h1><p>代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="comment">//使用系统时钟作为种子,time()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));	<span class="comment">//播种，产生随机数(其类型为unsigned int)</span></span><br><span class="line">	<span class="comment">//randomize();		        //也可用这个函数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n\n&quot;</span>, RAND_MAX<span class="comment">/*定义在stdlib.h中*/</span>);	<span class="comment">//产生随机数的最大值32767</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, rand());		       <span class="comment">//随机数范围为[0,32767]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//rand()/32767.0;产生[0,1]之间的随机数（注意此时的格式转换符要换成%f或%lf）</span></span><br><span class="line">		<span class="comment">//rand()%100;产生[0,100)之间的随机数</span></span><br><span class="line">		<span class="comment">//rand()%101;产生[0,100](因为产生的是整数，所以[0,101)与[0,100]是等价的）之间的随机数</span></span><br><span class="line">		<span class="comment">//rand()%a;产生[0,a)之间的随机数</span></span><br><span class="line">		<span class="comment">//rand()%(a+1);产生[0,a]之间的随机数</span></span><br><span class="line">		<span class="comment">//rand()%(a+1)+b;产生[a,a+b]之间的随机数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果如下：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/2229104-20210109213542768-308089942.png" alt=""></p>
<h1 id="数据类型的范围及其所占内存空间"><a href="#数据类型的范围及其所占内存空间" class="headerlink" title="数据类型的范围及其所占内存空间"></a>数据类型的范围及其所占内存空间</h1><h2 id="1-数据范围"><a href="#1-数据范围" class="headerlink" title="1.数据范围"></a>1.数据范围</h2><p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="comment">//利用标准头文件&lt;limts.h&gt;来确定个类型数据的范围，但是浮点型的范围不能用这种方法表示出来</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//signed types</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;signed char min=%d\n&quot;</span>, SCHAR_MIN);<span class="comment">//-2^7</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;signed char max=%d\n&quot;</span>, SCHAR_MAX);<span class="comment">//2^7-1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;signed short min=%d\n&quot;</span>, SHRT_MIN);<span class="comment">//-2^15</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;signed short max=%d\n&quot;</span>, SHRT_MAX);<span class="comment">//2^15-1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;signed int min=%d\n&quot;</span>, INT_MIN);<span class="comment">//-2^31</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;signed int max=%d\n&quot;</span>, INT_MAX);<span class="comment">//2^31-1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;signed long min=%ld\n&quot;</span>, LONG_MIN);<span class="comment">//-2^31</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;signed long max=%ld\n&quot;</span>, LONG_MAX);<span class="comment">//2^31-1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//unsigned types(最小值就是0)</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;unsigned char max=%u\n&quot;</span>, UCHAR_MAX);<span class="comment">//2^8-1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;unsigned short max=%u\n&quot;</span>, USHRT_MAX);<span class="comment">//2^16-1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;unsigned int max=%u\n&quot;</span>, UINT_MAX);<span class="comment">//2^32-1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;unsigned long max=%lu\n&quot;</span>, ULONG_MAX);<span class="comment">//2^32-1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%zd\t%zd\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>), <span class="keyword">sizeof</span>(<span class="keyword">signed</span> <span class="keyword">int</span>));</span><br><span class="line">	<span class="comment">//4，4</span></span><br><span class="line">	<span class="comment">//说明有无unsigned只会影响其所能容纳的数据的阈值，而其所占内存不变</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%zd\t%zd\t%zd\t%zd\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>), <span class="keyword">sizeof</span>(<span class="keyword">short</span>), <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">	<span class="comment">//1，2，4，4</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%zd\t%zd\t%zd\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>), <span class="keyword">sizeof</span>(<span class="keyword">float</span>), <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">	<span class="comment">//8,4,8</span></span><br><span class="line">	<span class="comment">//故char类型占1个字节，short类型占2个字节，int类型占4个字节</span></span><br><span class="line">        <span class="comment">//long类型：64位Windows中占4个字节，64位linux中占8个字节</span></span><br><span class="line">	<span class="comment">//long long类型占8个字节，float类型占4个字节，double类型占8个字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/2229104-20210109215905164-1472620072.png" alt=""></p>
<h2 id="2-强制类型转换"><a href="#2-强制类型转换" class="headerlink" title="2.强制类型转换"></a>2.强制类型转换</h2><blockquote>
<p>只有char与short、char与char、short与short之间的运算都是先将其转换为int型，再进行运算。而其他的情况都是先将其向容量大（能够表示数的范围）的一种类型转换，然后再进行运算的</p>
</blockquote>
<p>代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> charType = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	<span class="keyword">short</span> shortType = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> intType = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> longlongType = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">float</span> floatType = <span class="number">4.0</span>;</span><br><span class="line">	<span class="keyword">double</span> doubleType = <span class="number">5.0</span>;</span><br><span class="line">	<span class="comment">//先将其转换为int，再进行运算</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%zd\t%zd\t%zd\n&quot;</span>, <span class="keyword">sizeof</span>(charType + charType), <span class="keyword">sizeof</span>(charType + shortType), <span class="keyword">sizeof</span>(shortType + shortType));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int + longlong，则先将int转化为8个字节的longlong，再运算</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%zd\t%zd\t%zd\n&quot;</span>, <span class="keyword">sizeof</span>(intType + intType), <span class="keyword">sizeof</span>(intType + longlongType), <span class="keyword">sizeof</span>(longlongType + longlongType));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//float的表示范围比int要大（至于为何，比较复杂，此处不赘述，需要的可自行百度），故先将其转换为float，再运算</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%zd\t%zd\t%zd\n&quot;</span>, <span class="keyword">sizeof</span>(intType + floatType), <span class="keyword">sizeof</span>(intType + doubleType), <span class="keyword">sizeof</span>(floatType + doubleType));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//float的表示范围比longlong要大（原因同上），故先将其转换为float，再运算</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(longlongType + floatType));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果如下：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/2229104-20210109224453237-1687919133.png" alt=""></p>
<h1 id="最大公约数及最小公倍数"><a href="#最大公约数及最小公倍数" class="headerlink" title="最大公约数及最小公倍数"></a>最大公约数及最小公倍数</h1><p><strong>最小公倍数 = 两数之积 / 最大公约数，因此只要得出最大公约数，便可得出最小公倍数，下面将通过几种算法进行实现</strong></p>
<h2 id="1-辗转相除法（又称欧几里德算法）"><a href="#1-辗转相除法（又称欧几里德算法）" class="headerlink" title="1.辗转相除法（又称欧几里德算法）"></a>1.辗转相除法（又称欧几里德算法）</h2><blockquote>
<ul>
<li><p>较大的数 % 较小的数 = 第一余数</p>
</li>
<li><p>较小的数 % 第一余数 = 第二余数</p>
</li>
<li><p>第一余数 % 第二余数 = 第三余数</p>
</li>
<li><p>······</p>
</li>
</ul>
<p>直到结果为0</p>
</blockquote>
<p>代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1, num2;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> temp1, temp2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入两个数：&quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d,%d&quot;</span>,&amp;num1, &amp;num2);</span><br><span class="line">    temp1 = num1;</span><br><span class="line">    temp2 = num2;</span><br><span class="line">    <span class="keyword">if</span>(temp1 &lt; temp2)&#123;<span class="comment">//确保temp1为输入的两个数中，数值大的那个</span></span><br><span class="line">        temp = temp1;</span><br><span class="line">        temp1 = temp2;</span><br><span class="line">        temp2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*********************************************/</span></span><br><span class="line">    <span class="keyword">while</span>(temp1 % temp2)&#123;</span><br><span class="line">        temp = temp2;</span><br><span class="line">        temp2 = temp1 % temp2;</span><br><span class="line">        temp1 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/********************************************/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大公约数：%d\n&quot;</span>, temp2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最小公倍数：%d\n&quot;</span>, num1*num2 / temp2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果如下：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/2229104-20210111171736895-315719992.png" alt=""></p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/2229104-20210111171643588-400785892.png" alt=""></p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/2229104-20210111171933456-1652579882.png" alt=""></p>
<h2 id="2-更相减损法"><a href="#2-更相减损法" class="headerlink" title="2.更相减损法"></a>2.更相减损法</h2><blockquote>
<ul>
<li><p>判断两数是否是偶数，若是，则用2约简，否则执行下一步，约简到两者都不是偶数时，执行下一步</p>
</li>
<li><p>较大的数 - 较小的数 = 第一差</p>
</li>
<li><p>以较大的数减较小的数，接着把所得的差与较小的数比较，并以大数减小数。继续这个操作，直到所得的减数和差相等为止。</p>
</li>
<li><p>最后相等的值乘上2的幂（约简2的次数）即得最大公约数</p>
</li>
</ul>
</blockquote>
<p>代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*********************************************/</span></span><br><span class="line"><span class="keyword">while</span>(temp1 != temp2)&#123;</span><br><span class="line">    <span class="keyword">if</span>(temp1 &gt; temp2)</span><br><span class="line">        temp1 -= temp2;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        temp2 -= temp1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*********************************************/</span></span><br></pre></td></tr></table></figure><br>运行结果同上</p>
<h2 id="3-Stein算法"><a href="#3-Stein算法" class="headerlink" title="3.Stein算法"></a>3.Stein算法</h2><blockquote>
<p>由于对于两个数x y，若有x&gt;y，则必有：</p>
<ul>
<li><p>x,y均为偶数 $gcd(x,y)=2gcd(\frac{x}{2},\frac{y}{2})$</p>
</li>
<li><p>x,y均为奇数 $gcd(x,y)=gcd(\frac{x+y}{2},\frac{x-y}{2})$</p>
</li>
<li><p>x为奇y为偶 $gcd(x,y)=gcd(x,\frac{y}{2})$</p>
</li>
<li><p>x为偶y为奇 $gcd(x,y)=gcd(\frac{x}{2},y)$</p>
</li>
</ul>
<p>故只要将x，y依据上式换算成偶数，偶数换算成奇数后再次依据上式换算成新的偶数，每换算成一次偶数，记数加1，直到两个数最后相等，将相等的值乘上2的幂（计数值）即得最大公约数，</p>
<p>上式中的数并不一定必须是2，也可换成其他的任意的数，只不过2是最小的素数，此处便用了2 </p>
</blockquote>
<p>代码如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">Stein</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> power = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">if</span> (num2 == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num1 != num2)&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1 &amp; <span class="number">0x1</span>)&#123;<span class="comment">//when num1 is odd</span></span><br><span class="line">            <span class="keyword">if</span> (num2 &amp; <span class="number">0x1</span>)&#123;<span class="comment">//when num1 and num2 are both odd</span></span><br><span class="line">                num1 = (num1 + num2) &gt;&gt; <span class="number">1</span>;<span class="comment">//num1 = (num1 + num2)/2</span></span><br><span class="line">                num2 = num1  - num2;<span class="comment">//num2 = (num1 - num2)/2</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//when num1 is odd and num2 is even</span></span><br><span class="line">                num2 &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//when num1 is even</span></span><br><span class="line">            <span class="keyword">if</span> (num2 &amp; <span class="number">0x1</span>)&#123;<span class="comment">//when num1 and num2 are both even</span></span><br><span class="line">                num1 &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (num1 &lt; num2)&#123;<span class="comment">//ensure that num1 is greater than num2</span></span><br><span class="line">                    temp = num1;</span><br><span class="line">                    num1 = num2;</span><br><span class="line">                    num2 = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//when num1 is even and num2 is odd</span></span><br><span class="line">                num1 &gt;&gt;= <span class="number">1</span>;<span class="comment">//num1 = mum1/2</span></span><br><span class="line">                num2 &gt;&gt;= <span class="number">1</span>;<span class="comment">//num2 = num2/2</span></span><br><span class="line">                power++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (num1 &lt;&lt; power);<span class="comment">//gcd = num1 * 2^power</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*********************************************/</span></span><br><span class="line">    temp2 = Stein(temp1,temp2);</span><br><span class="line"><span class="comment">/*********************************************/</span></span><br></pre></td></tr></table></figure><br>运行结果同上</p>
<p><strong>stein算法是在欧几里德算法上做的改良，可以快速处理任何大数（超过128位的表示范围），而欧几里德算法遇到大数则需要很多时间（因为位运算和加减运算相较于取余运算来说，CPU的计算量更少）</strong></p>
<h1 id="查找一定范围内的素数"><a href="#查找一定范围内的素数" class="headerlink" title="查找一定范围内的素数"></a>查找一定范围内的素数</h1><p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;<span class="comment">//0 means not prime number, 1 means prime number</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">2</span>; index &lt;= <span class="built_in">sqrt</span>(num); index++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num%index == <span class="number">0</span>)&#123;</span><br><span class="line">            flag =<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> range, count = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入查找范围：&quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>,&amp;range);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d以内的素数如下：\n&quot;</span>,range);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2\t&quot;</span>);<span class="comment">//Don&#x27;t judge 2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">3</span>; index &lt;= range ; index += <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isPrime(index))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,index);</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count%<span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/2229104-20210112172426593-1257207043.png" alt="img"></p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/2229104-20210112172445999-1478334056.png" alt="img"></p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/2229104-20210112172521786-741779603.png" alt="img"></p>
<h1 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h1><blockquote>
<p>指针数组主要用于存放具有不同长度的字符串（存放多个字符串的最常用方式）</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">monthName</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//monthName函数返回第n个月份的名字，该函数的定义表明其monthName是一个函数，返回一个指向char类型的指针</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span>* name[] = &#123; <span class="string">&quot;Illegal month&quot;</span>,<span class="comment">//定义静态指针数组*name[]</span></span><br><span class="line">                             <span class="comment">//元素中存放的是各个字符串的地址</span></span><br><span class="line">                            <span class="string">&quot;January&quot;</span>, <span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>, <span class="string">&quot;July&quot;</span>, <span class="string">&quot;August&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;September&quot;</span>,<span class="string">&quot;October&quot;</span>,<span class="string">&quot;November&quot;</span>,<span class="string">&quot;December&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">1</span> || n&gt;<span class="number">12</span>) ? name[<span class="number">0</span>] : name[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入月份对应的数字：&quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>,&amp;number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, monthName(number));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/2229104-20210112174039305-1808900711.png" alt="img"></p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/2229104-20210112174058851-169109391.png" alt="img"></p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/2229104-20210112173904342-827953661.png" alt="img"></p>
<h1 id="统计单词数目"><a href="#统计单词数目" class="headerlink" title="统计单词数目"></a>统计单词数目</h1><p>由于每个单词字母不一样，长度不一样，所以来依靠<strong>识别单词</strong>来统计单词数是比较难的，下面观察一个字符串</p>
<blockquote>
<p>I am from China</p>
</blockquote>
<p>不难发现，每个单词后面都是紧跟一个空格的</p>
<p>因此可以使用一个标志flag来表示上一个字符的状态（0代表是空格），string[i]来表示当前字符的状态</p>
<p>那么在对输入的字符串进行遍历的时候，如果当前字符string[i]不是空格（string[i]!=’ ‘），而上一个字符是空格（flag==0），则说明有1个新单词</p>
<p>若当前字符不是空格（string[i]!=’ ‘），但是上一个字符也不是空格（flag==1），则说明正在遍历一个单词的内部字符，没有1个新的单词</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// flag==0 means a space</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入一句英文：&quot;</span>);</span><br><span class="line">    gets_s(<span class="built_in">string</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; <span class="built_in">string</span>[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">string</span>[i] == <span class="string">&#x27; &#x27;</span>)<span class="comment">// set flag to 0</span></span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;<span class="comment">// flag==0 and string[i]!=&#x27; &#x27; means a new word</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;count = %d&quot;</span>, count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;                        </span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/2229104-20210112184346385-768533576.png" alt="img"></p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/2229104-20210112185217988-467131753.png" alt="img"></p>
<h1 id="sizeof-s-和strlen-s-的区别"><a href="#sizeof-s-和strlen-s-的区别" class="headerlink" title="sizeof(s)和strlen(s)的区别"></a>sizeof(s)和strlen(s)的区别</h1><p>strlen(s)即字符串长度（不包括结束标志’\0’）：返回字符串中的所有字符的个数（1个汉字按2个字符算），其中，每个成对的符号如’’、”” 算作2个）；</p>
<p>字母以及英文符号（除标点符号及其他的特殊符号(如$)外还包括空白符）都只占一个字节，汉字以及中文符号都占两个字节</p>
<p>sizeof(s)即字符串所占空间（包括结尾的’\0’）</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span>* name1 = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span> name2[] = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;张三&quot;</span>));<span class="comment">//5，sizeof()返回值是size_t类型</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(name1));<span class="comment">//4，name1是一个指针类型的变量,所有指针类型都占4个字节，所以不论字符串中内容为何，sizeof(name1)始终为4</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;张三&quot;</span>));<span class="comment">//4</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="built_in">strlen</span>(name1));<span class="comment">//4，strlen()始终是计算字符串的长度，而不会去计算name1</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;zhangsan&quot;</span>));<span class="comment">//9</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(name2));<span class="comment">//9</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;zhangsan&quot;</span>));<span class="comment">//8</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="built_in">strlen</span>(name2));<span class="comment">//8</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/2229104-20210113122124714-1336883463.png" alt="img"></p>
<blockquote>
<p>查看类型定义，如下可以看到，strlen(s)和sizeof(s)一样都是size_t类型，在WIN64系统中，size_t类型是利用typedef给unsigned int类型取的一个别名，本质上还是unsigned int类型，占4个字节</p>
</blockquote>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/2229104-20210113123250302-743491501.png" alt="img"></p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/2229104-20210113121146758-2084078655.png" alt="img"></p>
<h1 id="const修饰符"><a href="#const修饰符" class="headerlink" title="const修饰符"></a>const修饰符</h1><p><strong>作用：只想让数据被使用而不能被修改</strong></p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1.const修饰基本数据类型--&gt;只能读不能改</span></span><br><span class="line">	<span class="comment">//只能在初始化时赋值</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> number = <span class="number">10</span>;<span class="comment">//&lt;=&gt;int const number=10，两中修饰方法都是相同的</span></span><br><span class="line">	<span class="comment">//不能对const修饰的变量进行修改，若加上 number = 1 则编译不通过</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;const修饰基本数据类型：%d\n&quot;</span>,number);<span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.const修饰数组：其元素值不能改</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123; <span class="number">10</span>,<span class="number">203</span>,<span class="number">123</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">213</span>,<span class="number">513</span>,<span class="number">1</span>,<span class="number">351</span>,<span class="number">34</span> &#125;;<span class="comment">//&lt;=&gt;int const array[]= &#123; 10,203,123,4,2,213,513,1,351,34 &#125;;</span></span><br><span class="line">	<span class="comment">//array[0]=99;//编译不通过</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;const修饰数组：&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++)</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,<span class="built_in">array</span>[index]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.const修饰指针</span></span><br><span class="line">	<span class="comment">//(1)只能修改地址来改变值（此种修饰指针方式较常用）</span></span><br><span class="line">	<span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>* pointer1 = &amp;num1;<span class="comment">//&lt;=&gt; int const *pointer1;</span></span><br><span class="line">	<span class="comment">//可以直接操作变量进行修改</span></span><br><span class="line">	num1 = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nconst修饰指针（1）：%d\t&quot;</span>, num1);<span class="comment">//200</span></span><br><span class="line">	<span class="comment">//不能通过修改*pointer1去修改其指向变量的值，即若加上 *pointer1=200; 则编译不通过</span></span><br><span class="line">	<span class="comment">//但可修改pointer1的值（即修改其指向变量的地址），如下：</span></span><br><span class="line">	<span class="keyword">int</span> num1_1 = <span class="number">100</span>;</span><br><span class="line">	pointer1 = &amp;num1_1;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*pointer1);<span class="comment">//18</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//(2)只能修改值，地址不能改</span></span><br><span class="line">	<span class="keyword">int</span> num2 = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span>* <span class="keyword">const</span> pointer2 = &amp;num2;</span><br><span class="line">	<span class="comment">//不能通过修改pointer2的值去修改其指向变量的值，即若加上 pointer2 = &amp;age2; 则编译不通过</span></span><br><span class="line">	<span class="comment">//但可修改*pointer2的值（即修改其指向变量的值）；</span></span><br><span class="line">	<span class="keyword">int</span> num2_2 = <span class="number">20</span>;</span><br><span class="line">	*pointer2 = num2_2;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;const修饰指针（2）：%d\n&quot;</span>,*pointer2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/2229104-20210113152157819-1668293423.png" alt="img"></p>
<h1 id="typedef类型定义"><a href="#typedef类型定义" class="headerlink" title="typedef类型定义"></a>typedef类型定义</h1><p><strong>作用：</strong></p>
<p><strong>1. 避免数据类型过长难以记忆和书写，如 “cosnt unsigned long long”、“struct student”，通过类似取别名的方式来简化数据类型的名称</strong></p>
<p><strong>2. 通过给一个数据类型取一个特定的别名，使得其为特定的数据服务，方便记忆和理解</strong></p>
<p><strong>注意：typedef类型定义一般写在最外面</strong></p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;1.</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    char* name;</span><br><span class="line">    int age;</span><br><span class="line">    int score;</span><br><span class="line">&#125; Student;</span><br><span class="line">&#x2F;&#x2F;2.</span><br><span class="line">typedef enum &#123;</span><br><span class="line">    DirectionEast,&#x2F;&#x2F;默认值为0</span><br><span class="line">    DirectionWest,&#x2F;&#x2F;默认值为1</span><br><span class="line">    DirectionSouth,&#x2F;&#x2F;默认值为2</span><br><span class="line">    DirectionNorth&#x2F;&#x2F;默认值为3</span><br><span class="line">&#125; Direction;</span><br><span class="line">&#x2F;&#x2F;3.</span><br><span class="line">typedef const unsigned long long cull;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Student stu &#x3D; &#123; &quot;ZhangSan&quot;,1,100&#125;;</span><br><span class="line">    Direction dir0 &#x3D; DirectionEast;</span><br><span class="line">    Direction dir1 &#x3D; DirectionWest;</span><br><span class="line">    Direction dir2 &#x3D; DirectionSouth;</span><br><span class="line">    Direction dir3 &#x3D; DirectionNorth;</span><br><span class="line">    cull number &#x3D; 3;</span><br><span class="line">    printf(&quot;stu.name:%s\n&quot;, stu.name);</span><br><span class="line">    printf(&quot;stu.age:%d\n&quot;, stu.age);</span><br><span class="line">    printf(&quot;stu.score:%d\n&quot;, stu.score);</span><br><span class="line"></span><br><span class="line">    printf(&quot;\nDirectionEast:%d\n&quot;, dir0);</span><br><span class="line">    printf(&quot;DirectionWest:%d\n&quot;, dir1);</span><br><span class="line">    printf(&quot;DirectionSouth:%d\n&quot;, dir2);</span><br><span class="line">    printf(&quot;DirectionNorth:%d\n&quot;, dir3);</span><br><span class="line"></span><br><span class="line">    printf(&quot;\nnumber:%lld\n&quot;,number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/2229104-20210113154722012-2055039727.png" alt="img"></p>
<h1 id="返回指针的函数"><a href="#返回指针的函数" class="headerlink" title="返回指针的函数"></a>返回指针的函数</h1><blockquote>
<p>函数的返回值可以是局部变量的返回值，但是不能返回局部变量的地址，因为当函数执行完毕后，局部变量的的空间会被回收</p>
<p>若要返回函数内部定义的指针，则需要将指针变量的存储空间申请在堆区</p>
<p>堆区的空间使用完之后，最后一定要释放掉</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">test</span><span class="params">()</span><span class="comment">//返回int类型的指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* pointer = <span class="built_in">calloc</span>(<span class="number">3</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//在堆内存中申请3个int类型大小的空间</span></span><br><span class="line"><span class="comment">//堆内存中申请空间（所用函数均在头文件stdlib.h中）：</span></span><br><span class="line"><span class="comment">//malloc(n)申请n个连续字节使用，并返回第一个字节的地址。不会自动清除垃圾值</span></span><br><span class="line"><span class="comment">//calloc(n,m)申请n个m个字节大的空间，并返回第一个字节的地址，如：calloc(4,sizeof(int))。自动清除垃圾值</span></span><br><span class="line"><span class="comment">//free释放空间</span></span><br><span class="line">    *pointer = <span class="number">10</span>;<span class="comment">//赋值</span></span><br><span class="line">    *(pointer + <span class="number">1</span>) = <span class="number">20</span>;</span><br><span class="line">    *(pointer + <span class="number">2</span>) = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">return</span> pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* pointer = test();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pointer[i]);</span><br><span class="line">    <span class="built_in">free</span>(pointer);<span class="comment">//堆内存的空间使用完之后，最后一定要释放掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/2229104-20210113162445937-1370537476.png" alt="img"></p>
]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Git命令</title>
    <url>/2021/02/02/Git_commands/</url>
    <content><![CDATA[<p>Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理，是Linus（Linux之父）为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。</p>
<p>由于我目前正在学习使用阶段，使用Git也仅限于保存学习过程中的代码，或者给一些文件用作备份，所以以下有一些未介绍的地方，以后补充。</p>
<a id="more"></a>
<h1 id="1-Git入门"><a href="#1-Git入门" class="headerlink" title="1.Git入门"></a>1.Git入门</h1><h2 id="1-1安装Git"><a href="#1-1安装Git" class="headerlink" title="1.1安装Git"></a>1.1安装Git</h2><ul>
<li><p>Windows</p>
<p>在官网下载Git最新版本后，安装。然后在命令窗口输入以下命令</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.name</span> <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.email</span> <span class="string">&quot;email@example.com&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台PC上所有的Git仓库都会使用这个配置</p>
</li>
<li><p>Mac OS X</p>
<p>就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装。需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了</p>
</li>
<li><p>Linux（Ubuntu）</p>
<p>在终端中输入<code>sudo apt-get install git</code>即可完成安装</p>
</li>
</ul>
<h2 id="1-2创建版本库"><a href="#1-2创建版本库" class="headerlink" title="1.2创建版本库"></a>1.2创建版本库</h2><p>版本库又名仓库（repository），可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”</p>
<p>所以，创建一个版本库十分简单。</p>
<p>首先在一个合适的地方创建一个空目录，然后进入该目录，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124134101593.png" alt="image-20210124134101593"></p>
<p>当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，不要随意更改目录中的内容</p>
<p>如果没有看到<code>.git</code>目录，那是因为它默认是隐藏的，用<code>ls -ah</code>命令就可以看见</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124163457340.png" alt="image-20210124134647313"></p>
<ul>
<li><p>将文件添加到版本库（仓库）</p>
<p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪 文本文件 的改动，比如txt文件、网页、所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p>
<p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的。使用版本控制系统时要以纯文本方式编写文件。</p>
<p>此外，千万不要使用Windows自带的<strong>记事本</strong>编辑任何文本文件，原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件。他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。故下载Notepad++代替记事本，记得把Notepad++的默认编码设置为UTF-8 without BOM</p>
<p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，建议使用UTF-8编码，被所有平台所支持</p>
<p>在git1目录下新建一个readme.txt文件（子目录下新建也可），内容如下</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">Nobody knows China better than <span class="keyword">me</span>.</span><br><span class="line">It<span class="comment">&#x27;s a fake news.</span></span><br><span class="line">没人能在法国投降之前占领巴黎。</span><br></pre></td></tr></table></figure>
<p>和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。</p>
<ul>
<li><p>第一步：用命令<code>git add</code>把文件添加到仓库</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> readme.txt</span></span><br></pre></td></tr></table></figure></li>
<li><p>第二步：用命令<code>git commit</code>把文件提交到仓库</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> commit -m <span class="string">&quot;first commit&quot;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124155134395.png" alt="image-20210124142530752"></p>
</li>
</ul>
<p>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，这样你就能从历史记录里方便地找到改动记录</p>
<p><code>1 file changed</code>说明1个文件被改动（我们新添加的readme.txt文件）</p>
<p><code>3 insertions</code>说明插入了3行内容（readme.txt有3行内容）。</p>
<p>可以多次<code>add</code>不同的文件，最后一次性全部提交，比如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> file1.txt</span></span><br><span class="line">git <span class="keyword">add</span><span class="bash"> file2.txt file3.txt</span></span><br><span class="line">git commit -m <span class="string">&quot;add 3 files.&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<p>Git命令必须在Git仓库目录内执行（<code>git init</code>除外），在仓库目录外执行是没有意义的</p>
<p>添加某个文件时，该文件必须在当前目录下存在，用<code>ls</code>或者<code>dir</code>命令查看当前目录的文件，看看文件是否存在，或者是否写错了文件名</p>
</li>
</ul>
<h2 id="1-3总结"><a href="#1-3总结" class="headerlink" title="1.3总结"></a>1.3总结</h2><p>初始化一个Git仓库，使用<code>git init</code>命令。</p>
<p>添加文件到Git仓库，分两步：</p>
<p>1.使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件</p>
<p>2.使用命令<code>git commit -m &lt;message&gt;</code>，提交</p>
<h1 id="2-时光机穿梭"><a href="#2-时光机穿梭" class="headerlink" title="2.时光机穿梭"></a>2.时光机穿梭</h1><h2 id="2-1修改文件"><a href="#2-1修改文件" class="headerlink" title="2.1修改文件"></a>2.1修改文件</h2><ul>
<li><p>修改readme.txt文件，用命令<code>git status</code>查看结果：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124142530752.png" alt="image-20210124155134395"></p>
<p>上述输出结果告诉我们：readme.txt`被修改过了，但还没有提交</p>
</li>
</ul>
<p>  若要查看修改的内容，则用命令<code>git diff readme.txt</code>：</p>
<p>  <img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124134647313.png" alt="image-20210124163457340"></p>
<p>  输出结果说明修改的内容为：</p>
<p>  将“没人能在法国头像之前占领巴黎。” 改为 “没人能在法国头像之前占领巴黎”</p>
<p>  若继续改动，在上一次修改的基础上将前两句的句号也都删除：</p>
<p>  <img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124174929199.png" alt="image-20210124173804691"></p>
<p>  可以发现，之前的修改并没有在保存到仓库中</p>
<p>  再修改一次，将首字母改为小写：</p>
<p>  <img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124173804691.png" alt="image-20210124174549168"></p>
<p>  可以看到，之前的修改仍然没有保存</p>
<p>  此时，将修改添加到仓库后查看仓库当前状态：</p>
<p>  <img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124174549168.png" alt="image-20210124174929199"></p>
<p>  可以看到，<code>changes to be committed</code>说明将要被提交的修改包括<code>readme.txt</code></p>
<p>  提交之后，再查看仓库状态：</p>
<p>  <img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124185500264.png" alt="image-20210124175611550"></p>
<p>​    Git告诉我们当前没有需要提交的修改，而且工作目录干净（working tree clean）</p>
<ul>
<li><p>总结</p>
<p>1.要随时掌握工作区的状态，使用<code>git status</code>命令</p>
<p>2.如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容</p>
</li>
</ul>
<h2 id="2-2版本回退"><a href="#2-2版本回退" class="headerlink" title="2.2版本回退"></a>2.2版本回退</h2><ul>
<li><p>首先，用<code>git log</code>命令查看提交（commit）的历史记录：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124175611550.png" alt="image-20210124183017705"></p>
<p>我们可以看到有2次提交，其中<code>first commit</code>和<code>second commit</code>是提交时加上的说明，当前仓库所处的状态是第2次提交之后的状态，若觉得容易眼花缭乱，可以加上<code>--pretty=oneline</code>参数：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124183017705.png" alt="image-20210124183720437"></p>
<p>在Git中，<code>HEAD</code>表示当前版本，上一个版本是<code>HEAD</code>\^，上上个版本是<code>HEAD</code>\^\^，上上上个版本是<code>HEAD</code>\^\^\^，前n个版本是<code>HEAD</code>~n</p>
</li>
<li><p>将当前版本（second commit）回退到上一个版本（first commit），用<code>reset</code>命令：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124183720437.png" alt="image-20210124185500264"></p>
<p><code>--hard</code>参数以后再说，现在先使用。结果显示当前版本的版本号<code>commit id</code>与第1次提交时的版本号一致，说明回退到了上一个版本。</p>
<p>如果不相信，可以通过<code>cat readme.txt</code>命令查看文件信息（cat命令是直接查看文件信息内容的）：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124190329356.png" alt="image-20210124185859799"></p>
<p>可以看到，此时<code>readme.txt</code>文件的内容与第1次提交时的一致，说明真的回退到了第1个版本</p>
</li>
</ul>
<p>  此时再查看仓库的状态：</p>
<p>  <img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124191403893.png" alt="image-20210124190329356"></p>
<p>   发现<code>second commit</code>版本已经消失不见了 。若想回到最新的版本<code>second commit</code>，则只要命令窗口没有关掉，就可以顺着窗口找到<code>second commit</code>版本的<code>commit id</code>，然后通过命令<code>git reset --hard 8e381</code>回退到之后的版本（版本号写前几位即可，Git会自己去找。当然了，也不能只写前一两位）。此时查看<code>readme.txt</code>的内容：</p>
<p>  <img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124185859799.png" alt="image-20210124191403893"></p>
<p>  可以看到，成功回退到了<code>second commit</code>版本。而且回退速度非常快，因为Git内部有个指向当前版本的<code>HEAD</code>指针。回退版本的时候，Git仅仅是将<code>HEAD</code>指针由指向<code>first commit</code>改为指向<code>second commit</code>，然后顺便把工作区的文件更新了，所以使<code>HEAD</code>指向哪个版本，就把当前版本定位在哪。</p>
<p>  然而如果窗口关掉了，那么再次打开Git Bash使用命令<code>git log</code>便看不到<code>second commit</code>版本的id号，自然也就无法回退版本了。此时可以用命令<code>git reflog</code>查看命令历史（记录每一次改变<code>HEAD</code>的命令），此处可以看到每次提交的版本号：</p>
<p>  <img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124194758839.png" alt="image-20210124194758839"></p>
<ul>
<li><p>总结</p>
<p>1.<code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code></p>
<p>2.穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本</p>
<p>3.要重返未来，用<code>git reflog</code>查看改变<code>HEAD</code>的命令历史，以便确定要回到未来的哪个版本</p>
</li>
</ul>
<h2 id="2-3工作区和暂存区"><a href="#2-3工作区和暂存区" class="headerlink" title="2.3工作区和暂存区"></a>2.3工作区和暂存区</h2><ul>
<li><p>工作区（Working Directory）</p>
<p>即在PC中能看到的目录，比如在我桌面上的git1文件夹就是一个工作区</p>
</li>
<li><p>版本库/仓库（Repository）</p>
<p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库</p>
<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及 指向<code>master</code>的一个指针 叫<code>HEAD</code>。分支和<code>HEAD</code>的概念以后再说</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/0.jpg"  /></p>
<p><code>git add</code>把文件添加进版本库，实际上就是把文件修改添加到暂存区</p>
<p><code>git commit</code>提交更改，实际上就是把暂存区的 所有内容 提交到当前分支</p>
<p>因为创建Git版本库时，Git自动为我们创建了唯一1个<code>master</code>分支，所以现在<code>git commit</code>就是往<code>master</code>分支上提交更改</p>
<p>可以简单理解为：需要提交的文件及修改通通放到暂存区，然后，一次性提交暂存区的所有修改</p>
</li>
<li><p>在<code>git1</code>目录下新建一个LICENSE文件，内容随便写；然后修改<code>readme.txt</code>文件：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124213528065.png" alt="image-20210124213528065"></p>
<p>Git非常清楚地说明了：<code>readme.txt</code>被修改了，而<code>LICENSE</code>还从来没有被添加过，所以它的状态是<code>Untracked</code></p>
</li>
</ul>
<p>  现在，使用命令<code>git add</code>，把<code>readme.txt</code>和<code>LICENSE</code>都添加后，用<code>git status</code>再查看一下：</p>
<p>  <img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124213644358.png" alt="image-20210124213644358"></p>
<p>  现在，暂存区的状态就变成了：</p>
<p>  <img src = "https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124213813600.png"></p>
<p>  一旦提交后，如果又没有对工作区做任何修改，那么工作区就是“干净”的：</p>
<p>  <img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/1.jpg" alt="image-20210124213813600"></p>
<p>  现在版本库中暂存区就没有任何内容了：</p>
<p>  <img src = "https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/2.jpg"></p>
<ul>
<li><p>总结</p>
<p>Git的暂存区十分重要</p>
</li>
</ul>
<h2 id="2-4管理修改"><a href="#2-4管理修改" class="headerlink" title="2.4管理修改"></a>2.4管理修改</h2><ul>
<li><p>Git追踪的并不是文件，而是修改</p>
<p>在文件中增加一行<code>年轻人不讲武德。</code>，然后添加，然后再次修改将其句号删掉，然后提交，查看状态：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124220836695.png" alt="image-20210124220836695"></p>
<p>可以发现，第2次的修改即删除句号没有被提交</p>
<p>整理一下过程：第1次修改 -&gt; <code>git add</code> -&gt; 第2次修改 -&gt; <code>git commit</code></p>
<p>其实，Git管理的是修改，当用<code>git add</code>命令后，工作区的第1次修改被放入暂存区，准备提交，但是，工作区的第2次修改并没有放入暂存区。所以<code>git commit</code>只负责把暂存区的修改（即第1次的修改）提交了，第2次的修改由于没有添加进暂存区，不会被提交</p>
<p>提交后，用<code>git diff</code>HEAD<code>-- readme.txt</code>命令可以查看 工作区（绿字） 与 版本库中的最新版本（红字） 之间的区别：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124221534325.png" alt="image-20210124221534325"></p>
<p>可见，第2次修改确实没有被提交</p>
<p>若想提交第2次修改，则只需将其添加，然后再提交即可：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124222059271.png" alt="image-20210124222059271"></p>
<p>可以看到，添加再提交后，工作区与版本库之间没有区别，所以用<code>git diff</code>HEAD<code>-- readme.txt</code>命令时没有显示（Unix的哲学即为“没有消息就是好消息”）</p>
</li>
<li><p>总结</p>
<p>每次修改文件，如果不用<code>git add</code>到暂存区，那么就不会加入到<code>commit</code>中</p>
</li>
</ul>
<h2 id="2-5撤销修改"><a href="#2-5撤销修改" class="headerlink" title="2.5撤销修改"></a>2.5撤销修改</h2><ul>
<li><p>工作区改乱了文件的内容（修改如下），但是修改之后的文件没有添加到暂存区</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124225508963.png" alt="image-20210124225508963"></p>
<p>若想直接丢弃工作区的修改，可以通过编辑文件手动修改，也可通过命令<code>git checkout -- file</code></p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124224317826.png" alt="image-20210124224317826"></p>
<p>命令<code>git checkout -- readme.txt</code>把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p>
<ul>
<li><p><code>readme.txt</code>修改后没有添加到暂存区，此时，撤销修改就回到和版本库一模一样的状态</p>
</li>
<li><p><code>readme.txt</code>添加到了暂存区，工作区的文件又做了修改，此时，撤销修改就回到添加到暂存区后的状态</p>
</li>
</ul>
<p>总之，命令<code>git checkout -- readme.txt</code>将使这个文件回退到最近一次<code>git commit</code>或<code>git add</code>时的状态</p>
<p>此外，<code>git checkout -- readme.txt</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令。此处不深究，分支管理中再细说</p>
</li>
<li><p>工作区改乱了文件的内容（修改如下），而且修改之后的文件还添加到了暂存区中</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124225410528.png" alt="image-20210124225410528"></p>
<p>若想直接丢弃暂存区，也可通过命令<code>git reset</code>HEAD<code>readme.txt</code>把暂存区的修改撤销掉（unstage），重新放回工作区，然后重复第一步即可</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124232241633.png" alt="image-20210124230438521"></p>
<p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区，当使用<code>HEAD</code>时，表示最新的版本</p>
</li>
<li><p>已经将修改提交到版本库时，想要撤销本次提交，只能通过版本回退来修改版本（不过前提是没有推送到远程库）</p>
</li>
<li><p>总结</p>
<p>1.场景1：当改乱工作区某个文件的内容，但没有添加到暂存区时，想要直接丢弃工作区的修改时，用命令<code>git chekout -- file</code></p>
<p>2.场景2：当不但改乱了工作区某个文件的内容，而且添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset</code>HEAD<code>&lt;file&gt;</code>，就回到了场景1，第二步按场景1操作</p>
<p>3.场景3：已经将修改提交到版本库时，想要撤销本次提交，只能通过版本回退来修改版本（不过前提是没有推送到远程库）</p>
</li>
</ul>
<h2 id="2-6删除文件"><a href="#2-6删除文件" class="headerlink" title="2.6删除文件"></a>2.6删除文件</h2><ul>
<li><p>首先，新建一个文本文件<code>test.txt</code>，内容随意，提交。一般是通过命令<code>rm test.txt</code>删除该文件。此时Git知道该文件已经删除了，故而工作区和版本库的文件就不一致了，<code>git status</code>命令会立刻告诉哪些文件被删除了</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124231804631.png" alt="image-20210124231804631"></p>
<p>现在有两个选择：</p>
<ul>
<li><p>要从版本库中删除该文件，那就用命令<code>git rm</code>删掉（与用<code>git add</code>效果一样），并且提交</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210125101015857.png" alt="image-20210124232241633"></p>
<p>这样文件从版本库中删除了</p>
<p>如果直接用<code>git rm test.txt</code>删除文件而不用<code>rm test.txt</code>，那么该文件是无法恢复的。总之一句话：<code>git rm</code>命令直接从版本库中删除文件</p>
</li>
<li><p>删错了，因为版本库中还有，所以可以很轻松地把误删的文件恢复到最新版本</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124230438521.png" alt="image-20210124232846497"></p>
<p><code>git checkout -- test.txt</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”</p>
</li>
</ul>
</li>
</ul>
<pre><code>注意：没有被添加（`git add`）到版本库的文件，删除之后是无法恢复的！换言之，添加（`git add`）后的文件删除（非`git rm`）之后是可以恢复的
</code></pre><h1 id="3-远程仓库"><a href="#3-远程仓库" class="headerlink" title="3.远程仓库"></a>3.远程仓库</h1><h2 id="3-1关联PC主机与GitHub服务器"><a href="#3-1关联PC主机与GitHub服务器" class="headerlink" title="3.1关联PC主机与GitHub服务器"></a>3.1关联PC主机与GitHub服务器</h2><p>实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交</p>
<p>完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫GitHub神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的。所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库</p>
<p>由于Git仓库与GitHub仓库之间的传输是通过SSH加密的，所以需要进行一些设置：</p>
<p>1.创建SSH Key。在用户主目录下（C:\Users\29239），看看有没有<code>.ssh</code>目录。如果有，再看看有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果有，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），输入如下命令创建SSH Key：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">ssh-keygen -<span class="built_in">t</span> rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span><br></pre></td></tr></table></figure>
<p>输入邮箱后，直接一路回车。如果一切顺利，可以在用户主目录里找到<code>.ssh</code>目录。里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210124232846497.png" alt="image-20210125101015857"></p>
<p>2.登录GitHub，打开“Account settings”，“SSH Keys”页面。然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容。点“Add Key”，你就应该看到已经添加的Key：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210125101217562.png" alt="image-20210125101217562"></p>
<p>当然，GitHub允许添加多个Key。假定有若干电脑，一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了</p>
<p>注意：在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去</p>
<p>如果不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是自己的Git服务器，所以别人也是看不见的</p>
<h2 id="3-2添加远程库"><a href="#3-2添加远程库" class="headerlink" title="3.2添加远程库"></a>3.2添加远程库</h2><p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，一举多得</p>
<ul>
<li><p>首先，登录GitHub，然后点击左上角repository的new按钮，创建一个新的仓库。然后在Repository name填入<code>git1</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210125104426601.png" alt="image-20210125102159633"></p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210125102159633.png" alt="image-20210125102513346"></p>
<p>目前，GitHub上的这个<code>git1</code>仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以 把一个已有的本地仓库与之关联 ，然后，把本地仓库的内容推送到GitHub仓库</p>
<p>现在，根据GitHub的提示，在本地的<code>git1</code>仓库下运行命令：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> remote add origin git@github.com:zhenyoung<span class="number">6</span>/git<span class="number">1</span>.git</span><br></pre></td></tr></table></figure>
<p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库</p>
<p>下一步，就可以把本地库的所有内容推送到远程库上：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">push</span> -u <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure>
<p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是 把当前分支<code>master</code>推送到远程 </p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210125105819675.png" alt="image-20210125104426601"></p>
<p>由于远程库是空的，第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送到远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令</p>
<p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210125102513346.png" alt="image-20210125104059199"></p>
<p>此后，只要本地作了提交，就可以通过命令：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure>
<p>把本地<code>master</code>分支的最新修改推送到GitHub</p>
</li>
<li><p>总结</p>
<p>1.要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code></p>
<p>2.关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容</p>
<p>此后，每次本地提交后，可以使用命令<code>git push origin master</code>推送最新修改</p>
<p>3.分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！而Git在有网络的时候，再把本地提交推送一下就完成了同步</p>
</li>
</ul>
<h2 id="3-3从远程库克隆"><a href="#3-3从远程库克隆" class="headerlink" title="3.3从远程库克隆"></a>3.3从远程库克隆</h2><p>上节中讲了先有本地库，后有远程库的时候，如何关联远程库。现在，假设从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆</p>
<ul>
<li><p>首先，登陆GitHub，创建一个新的仓库，名字叫<code>gitskills</code>：</p>
<p>现在，远程库已经准备好了，下一步是用命令<code>git clone</code>在<code>desktop</code>目录下克隆一个本地库：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/1.png" alt="image-20210125105819675"></p>
<p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了</p>
<p>此外我们注意到，GitHub给出的地址不止一个，还可以用<code>https://github.com/zhenyoung6/gitskills.git</code>这样的地址</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/2.png" alt="image-20210125110223367"></p>
<p>实际上，Git支持多种协议，默认的<code>git://</code>使用ssh，但也可以使用<code>https</code>等其他协议。使用<code>https</code>除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用<code>ssh</code>协议而只能用<code>https</code></p>
</li>
<li><p>总结</p>
<p>1.要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆</p>
<p>2.Git支持多种协议，包括<code>https</code>，但<code>ssh</code>协议速度最快</p>
</li>
</ul>
<h1 id="4-分支管理"><a href="#4-分支管理" class="headerlink" title="4.分支管理"></a>4.分支管理</h1><h2 id="4-1创建与合并分支"><a href="#4-1创建与合并分支" class="headerlink" title="4.1创建与合并分支"></a>4.1创建与合并分支</h2><ul>
<li><p>在版本回退中，已经了解到：每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫做主分支，即<code>master</code>分支。 <code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code> ，<code>master</code>才是指向提交的。所以，<code>HEAD</code>指向的就是当前分支</p>
<p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：</p>
<p><img src = "https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/3.png"></p>
<p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着不断提交，<code>master</code>分支的线也越来越长</p>
<p>当创建新的分支如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向与<code>master</code>相同的提交，再将<code>HEAD</code>改为指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p>
<p><img src = "https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210125104059199.png"></p>
<p>Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，更改<code>HEAD</code>的指向，工作区的文件都没有任何变化！</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p>
<p><img src = "https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/5.png"></p>
<p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。合并最简单的方法，就是将<code>master</code>指向 <code>dev</code>的当前提交 ，就完成了合并：</p>
<p><img src = "https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/4.png"></p>
<p>所以Git合并分支也很快！更改指针即可，工作区内容也不变！</p>
<p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p>
<p><img src = "https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210125110223367.png"></p>
</li>
<li><p>下面举一个例子</p>
<p>首先，创建<code>dev</code>分支，然后切换到<code>dev</code>分支：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">git</span> checkout -<span class="keyword">b</span> dev</span><br></pre></td></tr></table></figure>
<p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于两条命令：</p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line">git branch <span class="built_in">dev</span></span><br><span class="line">git checkout <span class="built_in">dev</span></span><br></pre></td></tr></table></figure>
<p>然后，用<code>git branch</code>命令查看当前分支：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210125225049612.png" alt="image-20210125225049612"></p>
<p><code>git branch</code>命令会列出所有分支，当前分支前会标一个<code>*</code>号</p>
<p>然后，就可以在<code>dev</code>分支上正常提交，比如对<code>readme.txt</code>做修改，加上一行：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">Creating a <span class="keyword">new</span> branch <span class="keyword">is</span> quick.</span><br></pre></td></tr></table></figure>
<p>然后提交，之后切换回<code>master</code>分支：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git checkout <span class="literal">master</span></span><br></pre></td></tr></table></figure>
<p>切换回<code>master</code>分支后，再查看<code>readme.txt</code>文件：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/6.png" alt="image-20210125225618044"></p>
<p>刚才添加的内容不见了！因为那个提交是在<code>dev</code>分支上，而<code>master</code>分支此刻的提交并没有改变：</p>
<p><img src = "https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210125230121019.png"></p>
<p>现在，将<code>dev</code>分支的工作成果合并到<code>master</code>分支上：</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">merge</span> dev</span><br></pre></td></tr></table></figure>
<p><code>git merge</code>命令用于合并指定分支到当前分支。合并后，再查看<code>readme.txt</code>的内容：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210125230531420.png" alt="image-20210125230121019"></p>
<p>可以看到，和<code>dev</code>分支的最新提交是完全一样的</p>
<p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快</p>
<p>当然，也不是每次合并都能<code>Fast-forward</code>，此处先按下不表，后面再提</p>
<p>合并完成后，就可以放心地删除<code>dev</code>分支了：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git branch -d dev</span></span><br></pre></td></tr></table></figure>
<p>删除后，查看<code>branch</code>，就只剩下<code>master</code>分支了：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210125233813834.png" alt="image-20210125230531420"></p>
<p> 因为创建、合并和删除分支非常快，所以Git鼓励使用分支完成某个任务，合并后再删掉分支，这与直接在<code>master</code>分支上工作效果是一样的，但过程更安全 </p>
</li>
<li><p>最新Git支持的<code>switch</code>命令</p>
<p>我们注意到切换分支使用<code>git checkout &lt;branch&gt;</code>，而前面讲过的撤销修改则是<code>git checkout -- &lt;file&gt;</code>。同一个命令，有两种作用，容易搞混且难以区分记忆</p>
<p>实际上，切换分支这个动作，用<code>switch</code>更科学。因此，最新版本的Git提供了新的<code>git switch</code>命令来切换分支</p>
<p>创建并切换到新的<code>dev</code>分支，可以使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">switch</span> -c dev</span><br></pre></td></tr></table></figure>
<p>直接切换到已有的<code>master</code>分支，可以使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">switch</span> master</span><br></pre></td></tr></table></figure>
<p>使用新的<code>git switch</code>命令，比<code>git checkout</code>要更容易理解</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210125225618044.png" alt="image-20210125233813834"></p>
</li>
<li><p>总结</p>
<p>Git鼓励大量使用分支：</p>
<ol>
<li>查看分支：<code>git branch</code></li>
<li>创建分支：<code>git branch &lt;name&gt;</code></li>
<li>切换分支：<code>git checkout &lt;name&gt;</code></li>
<li>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></li>
<li>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></li>
<li>删除分支：<code>git branch -d &lt;name&gt;</code></li>
</ol>
</li>
</ul>
<h2 id="4-2解决冲突"><a href="#4-2解决冲突" class="headerlink" title="4.2解决冲突"></a>4.2解决冲突</h2><ul>
<li><p>以下面一个例子说明冲突及如何解决冲突</p>
<p>创建新的分支：<code>git switch -c feature1</code></p>
<p>修改<code>readme.txt</code>最后一行，改为：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">Crreating a <span class="keyword">new</span> branch <span class="keyword">is</span> quick AND simple.</span><br></pre></td></tr></table></figure>
<p>然后在<code>feature1</code>分支上提交，然后切换到<code>master</code>分支：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210126003723275.png" alt="image-20210126003723275"></p>
<p><code>Your branch is ahead of &#39;origin/master&#39; by 1 commit.</code>提示我们：当前<code>master</code>分支比远程的<code>master</code>分支要超前1个提交</p>
<p>在<code>master</code>分支上把<code>readme.txt</code>文件的最后一行改为：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">Creating a <span class="keyword">new</span> branch <span class="keyword">is</span> quick &amp; simple.</span><br></pre></td></tr></table></figure>
<p>然后在<code>master</code>分支上提交：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/branch1.png" alt="image-20210126004422409"></p>
<p>现在，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样：</p>
<p><img src = "https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210126004422409.png"></p>
</li>
</ul>
<p>  此时，Git无法执行“快速合并”，只能试图把各自的修改合并起来，若执行合并命令：</p>
<p>  <img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210126005635204.png" alt="image-20210126005635204"></p>
<p>  可以发现：合并出现冲突且冲突出现在<code>readme.txt</code>文件中，必须解决冲突后提交</p>
<p>  <code>git status</code>也说明了冲突的文件：</p>
<p>  <img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210126010007855.png" alt="image-20210126010007855"></p>
<p>  查看<code>readme.txt</code>的内容：</p>
<p>  <img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/branch2.png" alt="image-20210126010235214"></p>
<p>  Git中使用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出分支之间相异的内容</p>
<p>  将<code>“年轻人不讲武德”</code>一句后修改为一行：</p>
  <figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">Creating a <span class="keyword">new</span> branch <span class="keyword">is</span> quick and simple.</span><br></pre></td></tr></table></figure>
<p>  提交之后，<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p>
<p>  <img src = "https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210126010748786.png"></p>
<p>  用带参数的<code>git log</code>也可以看到分支的合并情况：</p>
<p>  <img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210126010235214.png" alt="image-20210126010748786"></p>
<ul>
<li><p>总结</p>
<p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成</p>
<p>而解决冲突就是把Git合并失败的多份文件手动编辑为我们希望的内容，再提交</p>
<p>用<code>git log --graph</code>命令可以看到分支合并图</p>
</li>
</ul>
<h2 id="4-3分支管理策略"><a href="#4-3分支管理策略" class="headerlink" title="4.3分支管理策略"></a>4.3分支管理策略</h2><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息</p>
<p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge合并时生成一个新的commit提交，这样，从分支历史上就可以看出分支信息。</p>
<ul>
<li><p>下面举一个例子说明一下分支管理</p>
<p>首先，仍然创建并切换<code>dev</code>分支，修改<code>readme.txt</code>文件，并提交一个新的<code>commit</code>，然后切换回<code>master</code>。然后输入以下命令合并<code>dev</code>分支：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> merge --<span class="literal">no</span>-ff -m <span class="string">&quot;merge with no-ff&quot;</span> dev</span><br></pre></td></tr></table></figure>
<p><code>--no-ff</code>参数，表示禁用<code>Fast forward</code></p>
<p>因为本次合并要创建一个新的<code>commit</code>，所以要加上<code>-m</code>参数，把<code>commit</code>描述写进去</p>
<p>合并后，用<code>git log</code>查看分支历史：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/fast forward1.png" alt="image-20210126013421958"></p>
<p>可以看到，不使用<code>Fast forward</code>模式，<code>merge</code>后就像这样：</p>
</li>
</ul>
<p><img src = "https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210126013421958.png"></p>
<ul>
<li><p>分支策略</p>
<p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
<p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p>
<p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p>
<p>所以，团队合作的分支看起来就像这样：</p>
<p><img src = "https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/fast forward.png"></p>
</li>
<li><p>总结</p>
<p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并</p>
</li>
</ul>
<h2 id="4-4Bug分支"><a href="#4-4Bug分支" class="headerlink" title="4.4Bug分支"></a>4.4Bug分支</h2><h2 id="4-5Feature分支"><a href="#4-5Feature分支" class="headerlink" title="4.5Feature分支"></a>4.5Feature分支</h2><h2 id="4-6多人协作"><a href="#4-6多人协作" class="headerlink" title="4.6多人协作"></a>4.6多人协作</h2><h2 id="4-7Rebase"><a href="#4-7Rebase" class="headerlink" title="4.7Rebase"></a>4.7Rebase</h2><h1 id="5-标签管理"><a href="#5-标签管理" class="headerlink" title="5.标签管理"></a>5.标签管理</h1><p>标签<code>tag</code>就是一个让人容易记住的有意义的名字，它跟某个<code>commit</code>绑在一起。可以理解为：每个tag就对应着1个版本的<code>commit</code></p>
<ul>
<li><p>创建标签</p>
<p>首先，切换到需要打标签的分支上。然后，用命令<code>git tag &lt;name&gt;</code>就可以打一个新标签。可以用命令<code>git tag</code>查看所有标签：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210126154130846.png" alt="image-20210126152723642"></p>
<p>默认标签是打在最新提交的<code>commit</code>上的。有时候，如果忘了打标签，比如，现在已经是周五了，但本应该在周一打的标签没有打，怎么办？</p>
<p>方法是找到历史提交的commit id，然后打上就可以了：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210126154211177.png" alt="image-20210126153713606"></p>
<p>若要对最近的<code>conflict fixed</code>这次提交打标签，它对应的commit id是<code>5c03c59</code>，用命令<code>git tag v0.9 5c03c59</code>，然后再用<code>git tag</code>查看标签</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210126152723642.png" alt="image-20210126154130846"></p>
<p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210126154444485.png" alt="image-20210126154211177"></p>
<p>可以看到，<code>v0.9</code>确实打在<code>conflict fixed</code>这次提交上</p>
<p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> tag -a v<span class="number">0</span>.<span class="number">1</span> -m <span class="string">&quot;version 0.1 released&quot;</span> d<span class="number">22</span>cb<span class="number">3</span>a</span><br></pre></td></tr></table></figure>
<p>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210126153713606.png" alt="image-20210126154444485"></p>
<p>注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p>
</li>
<li><p>操作标签</p>
<p>如果标签打<code>v0.1</code>错了，也可以用命令<code>git tag -d v0.1</code>删除。因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除</p>
<p>如果要推送某个标签到远程，使用命令<code>git push origin v0.1</code></p>
<p>或者，一次性推送全部尚未推送到远程的本地标签<code>git push origin --tags</code></p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210126160958026.png" alt="image-20210126160150241"></p>
<p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除<code>git tag -d v0.9</code>。然后，从远程删除<code>git push origin :refs/tags/v0.9</code></p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210126160150241.png" alt="image-20210126161432619"></p>
<p>若要查看是否真的从远程库删除了标签，可以登陆GitHub查看是否真的从远程库删除了标签</p>
<p>以下删除了v0.9，还剩v1.0和v0.1版本</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210126160925273.png" alt="image-20210126160925273"></p>
</li>
</ul>
<p>  以下删除了v0.1，还剩v1.0版本</p>
<p>  <img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210126161128493.png" alt="image-20210126160958026"></p>
<p>  以下删除了最后的v1.0版本</p>
<p>  <img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210126161432619.png" alt="image-20210126161128493"></p>
<ul>
<li><p>总结</p>
<ol>
<li><p>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id</p>
</li>
<li><p>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息</p>
</li>
<li>命令<code>git tag</code>可以查看所有标签</li>
<li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签</li>
<li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签</li>
<li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签</li>
<li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签</li>
</ol>
</li>
</ul>
<h1 id="6-使用GitHub"><a href="#6-使用GitHub" class="headerlink" title="6.使用GitHub"></a>6.使用GitHub</h1><h1 id="7-使用Gitee"><a href="#7-使用Gitee" class="headerlink" title="7.使用Gitee"></a>7.使用Gitee</h1><h1 id="8-自定义Git"><a href="#8-自定义Git" class="headerlink" title="8.自定义Git"></a>8.自定义Git</h1><h1 id="9-使用SourceTree"><a href="#9-使用SourceTree" class="headerlink" title="9.使用SourceTree"></a>9.使用SourceTree</h1>]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Web前端</title>
    <url>/2021/02/09/web/</url>
    <content><![CDATA[<p>之前在写博客时有些需求是Markdown本身的语法不能满足的，必须使用HTML。而由于Markdown最后也是将Markdown的源码转换成HTML或者XHTML文档。最近有一点时间，开始学习一些常用的HTML标签以及CSS样式。由于我自己并不是一个专业的前端工程师，学习这些知识也仅仅是为了写博客时的一些格式，所以目前主要写的是关于HTML的。以后如果我想要深入了解CSS和JS，会继续写下去。因此这篇博客并不会涵盖所有的内容，只是粗略地学习一下。</p>
<a id="more"></a>
<h1 id="1-网页的结构"><a href="#1-网页的结构" class="headerlink" title="1.网页的结构"></a>1.网页的结构</h1><p>根据W3C（World Wide Web Consortium，万维网联盟）的标准，一个网页主要由三部分组成：结构、表现、行为。</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210209103456336.png" alt="image-20210209103456336"></p>
<p>结构：HTML用于描述页面的结构，类似人的骨架，是看不到的；<br>表现：CSS用于控制页面中元素的样式，类似人的皮肤、衣服等，是可以被人看到的；<br>行为：JavaScript用于响应用户操作，类似人的行为动作等。</p>
<h1 id="2-HTML（Hypertext-Markup-Language，超文本标记语言）介绍"><a href="#2-HTML（Hypertext-Markup-Language，超文本标记语言）介绍" class="headerlink" title="2.HTML（Hypertext Markup Language，超文本标记语言）介绍"></a>2.HTML（Hypertext Markup Language，超文本标记语言）介绍</h1><p>HTML使用标签的形式来表示网页中的不同组成部分。标签一般成对出现，但是也存在一些自动结束标签，下面列举一些简单的标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="comment">&lt;!--文档声明，声明当前网页的版本，此处是HTML5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="comment">&lt;!--网页的头部，不会在网页中直接出现，帮助浏览器或者搜索引擎来解析网页--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span><span class="comment">&lt;!--通过meta标签来设置网页的元数据，这里是设置字符集，避免乱码问题--&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--标签即元素，元素即标签--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>这是网页的标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="comment">&lt;!--title中的内容会显示在浏览器的标题栏，搜索引擎会根据title中的内容来判断网页的主要内容--&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="comment">&lt;!--body表示网页的主体，网页中所有的内容都应该写在body中--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是正文的一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是正文的二级标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h6</span>&gt;</span>这是正文的六级标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p1</span>&gt;</span><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span> <span class="attr">size</span>=<span class="string">&#x27;16&#x27;</span>&gt;</span>这是第一个自然段<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--font标签，不推荐使用，文本的表现样式都是属于CSS的范畴，所以在HTML中font标签尽量不用--&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;!DOCTYPE html&gt;</code>告诉浏览器：网页是基于HTML5版本的。<code>&lt;html&gt;&lt;/html&gt;</code>是根标签，内部有head和body两个子标签。head标签内部有一个title子标签，写网页的标题。body标签内部即为正文内容。<code>&lt;h1&gt;&lt;/h1&gt;</code>内部写的标题是正文的一个一级标题。<br>标签之中可以设置属性（字体的大小、颜色等），有些属性有属性值，有些没有。如果有属性值，则应该用引号引起来。</p>
<h2 id="实体（转义字符）"><a href="#实体（转义字符）" class="headerlink" title="实体（转义字符）"></a>实体（转义字符）</h2><p>在网页中，使用空格键输出的多个空格默认会被浏览器解析为一个空格，在HTML中的一些特殊符号如空格、小于号、大于号等，需要使用实体（或者称为转义字符）：<code>&amp;实体名;</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>实体</th>
<th>显示字符</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;nbsp;</code>（none break space，即不带换行的空格）</td>
<td>空格</td>
</tr>
<tr>
<td><code>&amp;gt;</code>（大于号）</td>
<td>&gt;</td>
</tr>
<tr>
<td><code>&amp;lt;</code>（小于号）</td>
<td>&lt;</td>
</tr>
<tr>
<td><code>&amp;copy;</code>（版权符号）</td>
<td>©</td>
</tr>
</tbody>
</table>
</div>
<p>1个<code>&amp;nbsp;</code>代表1个空格，3个<code>&amp;nbsp;</code>代表3个空格，其他的实体也是同样的。详细的实体符号查询，<a href="https://www.w3school.com.cn/html/html_entities.asp">点这</a></p>
<h1 id="3-标签"><a href="#3-标签" class="headerlink" title="3.标签"></a>3.标签</h1><h2 id="3-1meta标签"><a href="#3-1meta标签" class="headerlink" title="3.1meta标签"></a>3.1meta标签</h2><p>meta主要用于设置网页中的一些元数据，元数据不是给用户看的，以下为常用meta标签的属性</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>charset</code></td>
<td style="text-align:left">指定网页中的字符集</td>
</tr>
<tr>
<td style="text-align:left"><code>name</code></td>
<td style="text-align:left">指定数据的名称</td>
</tr>
<tr>
<td style="text-align:left"><code>content</code></td>
<td style="text-align:left">指定数据的内容</td>
</tr>
<tr>
<td style="text-align:left"><code>http-equiv</code></td>
<td style="text-align:left">将页面重定向到另一个网站</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-1-1name属性不同时的各种情况"><a href="#3-1-1name属性不同时的各种情况" class="headerlink" title="3.1.1name属性不同时的各种情况"></a>3.1.1name属性不同时的各种情况</h3><ol>
<li>Keywords</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相机,数码,配件,手表,存储卡,京东&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>设置一个元数据，名称为<code>Keywords</code>，值为<code>网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相机,数码,配件,手表,存储卡,京东</code>。name元素名称为Keywords表示网站的关键字，可以同时指定多个关键字，关键字使用英文逗号隔开。在上面一行代码中，如果搜索<code>网上购物</code>关键字或者<code>网上商城</code>等关键字，那么便会搜索到该网站</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210209210749079.png" alt="image-20210209210749079"></p>
<ol>
<li>description</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;京东JD.COM-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述代码中的<code>description</code>用于网站的描述，网站的描述会显示在搜索引擎的搜索结果中</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210209212504938.png" alt="image-20210209212504938"></p>
<p>既然说到了搜索引擎的搜索结果，那么就提一下：title标签的内容会作为搜索结果的超链接上方的文字显示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>京东(JD.COM)-正品低价、品质保障、配送及时、轻松购物！<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210209210805794.png" alt="image-20210209210805794"></p>
<h3 id="3-1-2http-equiv属性（较少用）"><a href="#3-1-2http-equiv属性（较少用）" class="headerlink" title="3.1.2http-equiv属性（较少用）"></a>3.1.2http-equiv属性（较少用）</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;3;https://www.baidu.com&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>上述代码将在3秒之后将网页重定向（即刷新）到百度的首页。</p>
<h2 id="3-2语义化标签"><a href="#3-2语义化标签" class="headerlink" title="3.2语义化标签"></a>3.2语义化标签</h2><h3 id="3-2-1常见标签"><a href="#3-2-1常见标签" class="headerlink" title="3.2.1常见标签"></a>3.2.1常见标签</h3><ul>
<li>标题标签：<code>&lt;h1&gt;head1&lt;/h1&gt;</code> ~ <code>&lt;h6&gt;head6&lt;/h6&gt;</code> 总共六级标签，一般情况下只会使用h1~h3，剩下的很少用。在页面中独占一行的元素称为块元素（block element）。标题标签就是一个块元素</li>
<li>段落标签：<code>&lt;p&gt;paragraph&lt;/p&gt;</code>表示页面中的一个段落，p标签也是一个块元素。</li>
<li>倾斜标签：<code>&lt;em&gt;emphasize&lt;/em&gt;</code>、<code>&lt;i&gt;italic&lt;/i&gt;</code>倾斜文本。推荐使用em标签，语气更加强烈。</li>
<li>加粗标签：<code>&lt;strong&gt;strong&lt;/strong&gt;</code>、<code>&lt;b&gt;bold&lt;/b&gt;</code>加粗文本。推荐使用strong标签。</li>
<li>删除线：<code>&lt;del&gt;delete&lt;/del&gt;</code>、<code>&lt;s&gt;strikethrough&lt;/s&gt;</code>添加删除线，推荐使用del标签。</li>
<li>下划线：<code>&lt;ins&gt;&lt;/ins&gt;</code>、<code>&lt;u&gt;underscore&lt;/u&gt;</code>添加下划线，推荐使用ins标签。</li>
<li>引用标签：<code>&lt;blockquote&gt;blockquote&lt;/blockquote&gt;</code>用来进行换行引用。而<code>&lt;q&gt;quote&lt;/q&gt;</code>用来进行不换行引用。</li>
<li>换行标签：<code>&lt;br/&gt;</code>用来进行换行</li>
</ul>
<h3 id="3-2-2布局标签（结构化）"><a href="#3-2-2布局标签（结构化）" class="headerlink" title="3.2.2布局标签（结构化）"></a>3.2.2布局标签（结构化）</h3><div class="table-container">
<table>
<thead>
<tr>
<th>标签</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;header&gt;&lt;/header&gt;</code></td>
<td>表示网页头部</td>
</tr>
<tr>
<td><code>&lt;main&gt;&lt;/main&gt;</code></td>
<td>表示网页主题部分，一个网页只能有一个main</td>
</tr>
<tr>
<td><code>&lt;footer&gt;&lt;/footer&gt;</code></td>
<td>表示网页底部</td>
</tr>
<tr>
<td><code>&lt;nav&gt;&lt;/nav&gt;</code></td>
<td>表示网页导航</td>
</tr>
<tr>
<td><code>&lt;article&gt;&lt;/article&gt;</code></td>
<td>表示一个独立的文章</td>
</tr>
<tr>
<td><code>&lt;aside&gt;&lt;/aside&gt;</code></td>
<td>表示与主题相关的其他内容（侧边栏）</td>
</tr>
<tr>
<td><code>&lt;section&gt;&lt;/section&gt;</code></td>
<td>表示一个独立的区块，上边的标签都不能表示时使用</td>
</tr>
<tr>
<td><code>&lt;div&gt;&lt;/div&gt;</code></td>
<td>没有语义，仅仅表示一个区块，目前仍是主要的布局元素</td>
</tr>
<tr>
<td><code>&lt;span&gt;&lt;/span&gt;</code></td>
<td>行内元素，没有语义，一般用于在网页中选中文字</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-2-3列表"><a href="#3-2-3列表" class="headerlink" title="3.2.3列表"></a>3.2.3列表</h3><p>无序列表使用<code>&lt;ul&gt;&lt;/ul&gt;</code>，有序列表使用<code>&lt;ol&gt;&lt;/ol&gt;</code>，使用<code>&lt;li&gt;list item&lt;/li&gt;</code>表示列表项。<br>定义列表使用<code>&lt;dl&gt;&lt;/dl&gt;</code>，使用<code>&lt;dt&gt;&lt;/dt&gt;</code>表示定义的内容，使用<code>&lt;dd&gt;&lt;/dd&gt;</code>来对内容进行解释说明。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;https://www.baidu.com&quot;&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 3秒后将页面刷新到百度首页 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- hgroup标签用来为标题分组，可以将一组相关的标题同时放到hgroup --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hgroup</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>回乡偶书&lt;/h1 &gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>其一<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">hgroup</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        鲁迅说过：<span class="tag">&lt;<span class="name">blockquote</span>&gt;</span>我没说过这句话<span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line">        孔子说过：<span class="tag">&lt;<span class="name">q</span>&gt;</span>学而时习之，不亦乐乎<span class="tag">&lt;/<span class="name">q</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span>break return</span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>结构<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>表现<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>行为<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>结构<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>表现<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>行为<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dt</span>&gt;</span>结构<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dd</span>&gt;</span>结构表示网页的结构<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dd</span>&gt;</span>结构表示网页的结构<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dd</span>&gt;</span>结构表示网页的结构<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-3特殊标签"><a href="#3-3特殊标签" class="headerlink" title="3.3特殊标签"></a>3.3特殊标签</h2><h3 id="3-3-1超链接"><a href="#3-3-1超链接" class="headerlink" title="3.3.1超链接"></a>3.3.1超链接</h3><p>跳转到其他页面或者当前页面的其他位置，超链接也是一个行内元素。通过a标签的href属性可以跳转到目标路径。如果超链接的对象是文件（图片、音频、视频、文本文件等）或者压缩包，则点击超链接会自动下载该文件。</p>
<p>当需要跳转到一个服务器内部的页面时，一般使用相对路径，如果不写目录，则默认是在该HTML文件所在目录。<br>关于是否是在当前网页打开超链接还是在新页面打开超链接，取决于target属性值：<br><code>self</code>（默认值）在当前页面中打开超链接<br><code>blank</code>在一个新的页面中打开超链接<br></p>
<p>href属性设置为<code>#</code>，页面不会发生跳转，而是转到当前页面的顶部的位置<br>id属性（唯一不重复的）：每一个标签都可以添加一个id属性，id属性就是元素的唯一标识，同一个页面中不能重复出现的id属性，并且是区分大小写的，一般是小写<br>只要将href属性设置为<code>#目标元素的id属性值</code>，便能跳转到目标元素处的位置</p>
<p>暂时不知道具体的指向的超链接可写作<code>&lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;index.html&quot;</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;./01.html&quot;</span>&gt;</span>01.html<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;./index.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#bottom&quot;</span>&gt;</span>底部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#paragraph_4&quot;</span>&gt;</span>第4自然段<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#paragraph_9&quot;</span>&gt;</span>第9自然段<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我比现在年轻十岁的时候，获得了一个游手好闲的职业，去乡间收集民间歌谣。那一年的整个夏天，我如同一只乱飞的麻雀，游荡在知了和阳光充斥的村舍田野。我喜欢喝农民那种带有苦味的茶水，他们的茶桶就放在田埂的树下，我毫无顾忌地拿起漆满茶垢的茶碗舀水喝，还把自己的水壶灌满，与田里干活的男人说上几句废话，在姑娘因我而起的窃窃私笑里扬长而去。我曾经和一位守着瓜田的老人聊了整整一个下午，这是我有生以来瓜吃得最多的一次，当我站起来告辞时，突然发现自己像个孕妇一样步履艰难了。然后我与一位当上了祖母的女人坐在门槛上，她编着草鞋为我唱了一支《十月怀胎》。我最喜欢的是傍晚来到时，坐在农民的屋前，看着他们将提上的井水泼在地上，压住蒸腾的尘土，夕阳的光芒在树梢上照射下来，拿一把他们递过来的扇子，尝尝他们和盐一样咸的咸菜，看看几个年轻女人，和男人们说着话。</span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我头戴宽边草帽，脚上穿着拖鞋，一条毛巾挂在身后的皮带上，让它像尾巴似的拍打着我的屁股。我整日张大嘴巴打着呵欠，散漫地走在田间小道上，我的拖鞋吧哒吧哒，把那些小道弄得尘土飞扬，仿佛是车轮滚滚而过时的情景。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我到处游荡，已经弄不清楚哪些村庄我曾经去过，哪些我没有去过。我走近一个村子时，常会听到孩子的喊叫：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;paragraph_4&quot;</span>&gt;</span>&quot;那个老打呵欠的人又来啦。&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>于是村里人就知道那个会讲荤故事会唱酸曲的人又来了。其实所有的荤故事所有的酸曲都是从他们那里学来的，我知道他们全部的兴趣在什么地方，自然这也是我的兴趣。我曾经遇到一个哭泣的老人，他鼻青眼肿地坐在田埂上，满腹的悲哀使他变得十分激动，看到我走来他仰起脸哭声更为响亮。我问他是谁把他打成这样的？他手指挖着裤管上的泥巴，愤怒地告诉我是他那不孝的儿子，当我再问为何打他时，他支支吾吾说不清楚了，我就立刻知道他准是对儿媳干了偷鸡摸狗的勾当。还有一个晚上我打着手电赶夜路时，在一口池塘旁照到了两段赤裸的身体，一段压在另一段上面，我照着的时候两段身体纹丝不动，只是有一只手在大腿上轻轻搔痒，我赶紧熄灭手电离去。在农忙的一个中午，我走进一家敞开大门的房屋去找水喝，一个穿短裤的男人神色荒张地挡住了我，把我引到井旁，殷勤地替我打上来一桶水，随后又像耗子一样窜进了屋里。这样的事我屡见不鲜，差不多和我听到的歌谣一样多，当我望着到处都充满绿色的土地时，我就会进一步明白庄稼为何长得如此旺盛。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>那个夏天我还差一点谈情说爱，我遇到了一位赏心悦目的女孩，她黝黑的脸蛋至今还在我眼前闪闪发光。我见到她时，她卷起裤管坐在河边的青草上，摆弄着一根竹竿在照看一群肥硕的鸭子。这个十六七岁的女孩，羞怯地与我共同度过了一个炎热的下午，她每次露出笑容时都要深深地低下头去，我看着她偷偷放下卷起的裤管，又怎样将自己的光脚丫子藏到草丛里去。那个下午我信口开河，向她兜售如何带她外出游玩的计划，这个女孩又惊又喜。我当初情绪激昂，说这些也是真心实意。我只是感到和她在一起身心愉快，也不去考虑以后会是怎样。可是后来，当她三个强壮如牛的哥哥走过来时，我才吓一跳，我感到自己应该逃之夭夭了，否则我就会不得不娶她为妻。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我遇到那位名叫福贵的老人时，是夏天刚刚来到的季节。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>那天午后，我走到了一棵有着茂盛树叶的树下，田里的棉花已被收起，几个包着头巾的女人正将棉秆拔出来，她们不时抖动着屁股摔去根须上的泥巴。我摘下草帽，从身后取过毛巾擦起脸上的汗水，身旁是一口在阳光下泛黄的池塘，我就靠着树干面对池塘坐了下来，紧接着我感到自己要睡觉了，就在青草上躺下来，把草帽盖住脸，枕着背包在树荫里闭上了眼睛。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;paragraph_9&quot;</span>&gt;</span>这位比现在年轻十岁的我，躺在树叶和草丛中间，睡了两个小时。其间有几只蚂蚁爬到了我的腿上，我沉睡中的手指依然准确地将它们弹走。后来仿佛是来到了水边，一位老人撑着竹筏在远处响亮地吆喝。我从睡梦里挣脱而出，吆喝声在现实里清晰地传来，我起身后，看到近旁田里一个老人正在开导一头老牛。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>犁田的老牛或许已经深感疲倦，它低头伫立在那里，后面赤裸着脊背扶犁的老人，对老牛的消极态度似乎不满，我听到他嗓音响亮地对牛说道：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&quot;做牛耕田，做狗看家，做和尚化缘，做鸡报晓，做女人织布，哪只牛不耕田？这可是自古就有的道理，走呀，走呀。&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>疲倦的老牛听到老人的吆喝后，仿佛知错般地抬起了头，拉着犁往前走去。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我看到老人的脊背和牛背一样黝黑，两个进入垂暮的生命将那块古板的田地耕得哗哗翻动，犹如水面上掀起的波浪。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>随后，我听到老人粗哑却令人感动的嗓音，他唱起了旧日的歌谣，先是口依呀啦呀唱出长长的引子，接着出现两句歌词-- 皇帝招我做女婿，　　路远迢迢我不去。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>因为路途遥远，不愿去做皇帝的女婿。老人的自鸣得意让我失声而笑。可能是牛放慢了脚步，老人又吆喝起来：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&quot;二喜，有庆不要偷懒；家珍，凤霞耕得好；苦根也行啊。&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>一头牛竟会有这么多名字？我好奇地走到田边，问走近的老人：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&quot;这牛有多少名字？&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>老人扶住犁站下来，他将我上下打量一番后问：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&quot;你是城里人吧？&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&quot;是的。&quot;我点点头。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>老人得意起来，&quot;我一眼就看出来了。&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我说：&quot;这牛究竟有多少名字？&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>老人回答：&quot;这牛叫福贵，就一个名字。&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&quot;可你刚才叫了几个名字。&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&quot;噢--&quot;老人高兴地笑起来，他神秘地向我招招手，当我凑过去时，他欲说又止，他看到牛正抬着头，就训斥它：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&quot;你别偷听，把头低下。&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>牛果然低下了头，这时老人悄声对我说：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&quot;我怕它知道只有自己在耕田，就多叫出几个名字去骗它，它听到还有别的牛也在耕田，就不会不高兴，耕田也就起劲啦。&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>老人黝黑的脸在阳光里笑得十分生动，脸上的皱纹欢乐地游动着，里面镶满了泥土，就如布满田间的小道。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这位老人后来和我一起坐在了那棵茂盛的树下，在那个充满阳光的下午，他向我讲述了自己。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>四十多年前，我爹常在这里走来走去，他穿着一身黑颜色的绸衣，总是把双手背在身后，他出门时常对我娘说：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&quot;我到自己的地上去走走。&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我爹走在自己的田产上，干活的佃户见了，都要双手握住锄头恭敬地叫一声：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&quot;老爷。&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我爹走到了城里，城里人见了都叫他先生。我爹是很有身份的人，可他拉屎时就像个穷人了。他不爱在屋里床边的马桶上拉屎，跟牲畜似的喜欢到野地里去拉屎。每天到了傍晚的时候，我爹打着饱嗝，那声响和青蛙叫唤差不多，走出屋去，慢吞吞地朝村口的粪缸走去。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>走到了粪缸旁，他嫌缸沿脏，就抬脚踩上去蹲在上面。我爹年纪大了，屎也跟着老了，出来不容易，那时候我们全家人都会听到他在村口嗷嗷叫着。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>几十年来我爹一直这样拉屎，到了六十多岁还能在粪缸上一蹲就是半晌，那两条腿就和鸟爪一样有劲。我爹喜欢看着天色慢慢黑下来，罩住他的田地。我女儿凤霞到了三、四岁，常跑到村口去看她爷爷拉屎，我爹毕竟年纪大了，蹲在粪缸上腿有些哆嗦，凤霞就问他：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&quot;爷爷，你为什么动呀？&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我爹说：&quot;是风吹的。&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>那时候我们家境还没有败落，我们徐家有一百多亩地，从这里一直到那边工厂的烟囱，都是我家的。我爹和我，是远近闻名的阔老爷和阔少爷，我们走路时鞋子的声响，都像是铜钱碰来撞去的。我女人家珍，是城里米行老板的女儿，她也是有钱人家出生的。有钱人嫁给有钱人，就是把钱堆起来，钱在钱上面哗哗地流，这样的声音我有四十年没有听到了。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是我们徐家的败家子，用我爹的话说，我是他的孽子。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我念过几年私塾，穿长衫的私塾先生叫我念一段书时，是我最高兴的。我站起来，拿着本线装的《千字文》，对私塾先生说：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&quot;好好听着，爹给你念一段。&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>年过花甲的私塾先生对我爹说：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&quot;你家少爷长大了准能当个二流子。&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我从小就不可救药，这是我爹的话。私塾先生说我是朽木不可雕也。现在想想他们都说对了，当初我可不这么想，我想我有钱呵，我是徐家仅有的一根香火，我要是灭了，徐家就得断子绝孙。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>上私塾时我从来不走路，都是我家一个雇工背着我去，放学时他已经恭恭敬敬地弯腰蹲在那里了，我骑上去后拍拍雇工的脑袋，说一声：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&quot;长根，跑呀。&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>雇工长根就跑起来，我在上面一颠一颠的，像是一只在树梢上的麻雀。我说一声：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&quot;飞呀。&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>长根就一步一跳，做出一副飞的样子。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我长大以后喜欢往城里跑，常常是十天半月不回家。我穿着白色的丝绸衣衫，头发抹得光滑透亮，往镜子前一站，我看到自己满脑袋的黑油漆，一副有钱人的样子。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我爱往妓院钻，听那些风骚的女人整夜叽叽喳喳和哼哼哈哈，那些声音听上去像是在给我挠痒痒。做人呵，一旦嫖上以后，也就免不了要去赌。这个嫖和赌，就像是胳膊和肩膀连在一起，怎么都分不开。后来我更喜欢赌博了，嫖妓只是为了轻松一下，就跟水喝多了要去方便一下一样，说白了就是撒尿。赌博就完全不一样了，我是又痛快又紧张，特别是那个紧张，有一股叫我说不出来的舒坦。以前我是过一天和尚撞一天钟，整天有气无力，每天早晨醒来犯愁的就是这一天该怎么打发。我爹常常唉声叹气，训斥我没有光耀祖宗。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我心想光耀祖宗也不是非我莫属，我对自己说：&quot;凭什么让我放着好端端的日子不过，去想光耀祖宗这些累人的事。再说我爹年轻时也和我一样，我家祖上有两百多亩地，到他手上一折腾就剩一百多亩了。我对爹说：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&quot;你别犯愁啦，我儿子会光耀祖宗的。&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>总该给下一辈留点好事吧。我娘听了这话吃吃笑，她偷偷告诉我：&quot;我爹年轻时也这么对我爷爷说过。我心想就是嘛，他自己干不了的事硬要我来干，我怎么会答应。那时候我儿子有庆还没出来，我女儿凤霞刚好四岁。家珍怀着有庆有六个月了，自然有些难看，走路时裤裆里像是夹了个馒头似的一撇一撇，两只脚不往前往横里跨，我嫌弃她，对她说：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&quot;你呀，风一吹肚子就要大上一圈。&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>家珍从不顶撞我，听了这糟蹋她的话，她心里不乐意也只是轻轻说一句：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&quot;又不是风吹大的。&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;bottom&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>回到顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span>&gt;</span>这是一个暂时没有指向的超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-2图片标签"><a href="#3-3-2图片标签" class="headerlink" title="3.3.2图片标签"></a>3.3.2图片标签</h3><p>图片标签用于向当前页面中引入一个外部图片。使用img标签来引入外部图片，img标签是一个自结束标签，属于替换元素（基于块和行内元素之间，具有两种元素的特点）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>src</td>
<td style="text-align:center">图片的地址</td>
</tr>
<tr>
<td>alt</td>
<td style="text-align:center">图片的描述，默认不会显示，搜索引擎会根据alt中的内容来识别图片，图片无法显示时会将alt内容显示出来</td>
</tr>
<tr>
<td>width</td>
<td style="text-align:center">图片的宽度（单位为像素）</td>
</tr>
<tr>
<td>height</td>
<td style="text-align:center">图片的高度（单位为像素）</td>
</tr>
</tbody>
</table>
</div>
<p>图片宽度和高度如果只修改了一个，则另一个会等比例缩放，一般也只改一个属性值。</p>
<ul>
<li>图片格式<br>jpeg（或者jpg，两者是一样的）：支持颜色较丰富，不支持透明效果，不支持动图。一般用来显示照片。<br>gif：支持颜色较少，支持简单透明，支持动图。一般用来显示颜色单一、动图。<br>png：支持颜色丰富，支持复杂透明度，不支持动图。适合颜色丰富，复杂透明度的图片。<br>webp：谷歌推出专门用来表示网页图片的一种格式，它具备上述3中图片格式的所有优点，而且文件还小，但兼容性差。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/zhenyoung.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span>  <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/zhenyoung.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span>  <span class="attr">width</span>=<span class="string">&quot;100&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/zhenyoung.jpg&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--给图片添加一个超链接--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://baike.baidu.com/pic/%E6%9D%8E%E7%99%BD/1043/1/78310a55b319ebc4acda9dc68126cffc1f1716ca?fr=lemma&amp;ct=single#aid=1&amp;pic=78310a55b319ebc4acda9dc68126cffc1f1716ca&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/libai1.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-3内联框架"><a href="#3-3-3内联框架" class="headerlink" title="3.3.3内联框架"></a>3.3.3内联框架</h3><p>用于向当前页面中引入一个其他页面，src属性中输入引入网页的url。frameborder属性指定内联框架的边框，0代表无边框，1代表有边框</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://www.qq.com&quot;</span> <span class="attr">width</span>=<span class="string">&quot;1300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-4音视频标签"><a href="#3-3-4音视频标签" class="headerlink" title="3.3.4音视频标签"></a>3.3.4音视频标签</h3><p>音频使用audio标签，视频使用video标签。<br>加上controls属性就能够使其被用户控制播放，若没有写<code>controls</code>则用户在该页面是无法控制播放音频和视频的。加上loop属性，音视频就能循环播放。加上autopaly属性，音视频便能自动播放，但是这个属性基本上不用。这三个属性都是不用给值的，写上就是有，没写就是没有。此外，音视频也都是可以加上width和height属性的。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>controls</td>
<td style="text-align:center">是否控制播放</td>
</tr>
<tr>
<td>loop</td>
<td style="text-align:center">是否循环播放</td>
</tr>
<tr>
<td>autoplay</td>
<td style="text-align:center">是否自动播放</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span> <span class="attr">loop</span> <span class="attr">src</span>=<span class="string">&quot;https://pic-blogs.oss-cn-beijing.aliyuncs.com/audio/MY%20ALL.mp3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">loop</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://pic-blogs.oss-cn-beijing.aliyuncs.com/video/Dream%20It%20Possible.mp4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="4-CSS（Cascading-Style-Sheet，层叠样式表）介绍"><a href="#4-CSS（Cascading-Style-Sheet，层叠样式表）介绍" class="headerlink" title="4.CSS（Cascading Style Sheet，层叠样式表）介绍"></a>4.CSS（Cascading Style Sheet，层叠样式表）介绍</h1><p>网页实际上是一个多层的结构，通过CSS可以分别为网页的每个层来设置样式，而最终我们能够看到的只是网页的最上边一层。凡是网页中外在表现出来的都可以算是表现。</p>
<p>使用CSS来修改元素的样式：<br>1.使用内联样式/行内样式：在需要添加样式的标签内部写入style属性<br>2.使用内部样式表：在head标签内通过style标签使得<br>3.使用外部样式表：在同级目录中新建一个.css文件写入样式即可<br>由于表现与结构是分开的，如果使用内联样式通过style属性设置样式，那么结构与表现还是有着非常紧密的联系，为了将两者分开，所以第1种方式基本不用，舍弃掉。<br>而第2种也仅仅实在head标签内写入style样式，仅限于当前该html文件中使用。<br>现实中往往是多个html都能共用1个样式，那么第3种方式便应用广泛了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 内部样式表（很少用）所有的p标签都共用该样式 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;style&gt;</span></span><br><span class="line"><span class="comment">    /* 所有的p标签都共用该样式 */</span></span><br><span class="line"><span class="comment">        p&#123;</span></span><br><span class="line"><span class="comment">            color:red;</span></span><br><span class="line"><span class="comment">            font-size:40px;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &lt;/style&gt; --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 外部样式表（最常用） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 内联样式/行内样式（基本不用） --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;p style=&quot;color:red; font-size: 50px;&quot;&gt;少小离家老大回，乡音无改鬓毛衰&lt;/p&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>落霞与孤鹜齐飞，秋水共长天一色<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="4-1选择器"><a href="#4-1选择器" class="headerlink" title="4.1选择器"></a>4.1选择器</h2><p>内部样式表中的style标签内部是遵守CSS语法规范的，与HTML是隔离的</p>
<h3 id="4-1-1普通选择器"><a href="#4-1-1普通选择器" class="headerlink" title="4.1.1普通选择器"></a>4.1.1普通选择器</h3><ul>
<li>元素选择器（对应元素都使用该样式）</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:blue;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>id选择器（对应id的标签使用该样式，id不能重复）</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#yellow</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>类选择器 <br>class属性是标签的一个属性，与id类似，不同的是class属性是可以重复使用的。一个元素可使用多个class，不同class之间使用空格隔开</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.color_orange</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通配选择器</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    <span class="comment">/*选择页面中所有的元素*/</span></span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-2复合选择器"><a href="#4-1-2复合选择器" class="headerlink" title="4.1.2复合选择器"></a>4.1.2复合选择器</h3><ul>
<li>交集选择器<br>选中同时符合符合多个条件的多个元素。如果交集选择器中有元素选择器，必须使用元素选择器开头，如<code>div.red</code></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.red</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.a</span><span class="selector-class">.b</span><span class="selector-class">.c</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>并集选择器（选择器分组）</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h2</span>,<span class="selector-tag">span</span>&#123;</span><br><span class="line">    <span class="comment">/*h1元素或span元素都使用绿色样式*/</span></span><br><span class="line">    <span class="attribute">color</span>:green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-3关系选择器"><a href="#4-1-3关系选择器" class="headerlink" title="4.1.3关系选择器"></a>4.1.3关系选择器</h3><ul>
<li>子元素选择器（少用）</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*将div元素的子元素span使用绿色样式，有class属性为tag1的div元素的子元素span使用棕色样式*/</span></span><br><span class="line"><span class="selector-tag">div</span> &gt; <span class="selector-tag">span</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.tag1</span> &gt; <span class="selector-tag">span</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:brown;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>后代元素选择器（范围比子元素选择器大，因此更常用）</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">p</span> <span class="selector-tag">span</span>&#123;</span><br><span class="line">    <span class="comment">/*div的子元素p的子元素span使用天空蓝样式*/</span></span><br><span class="line">    <span class="attribute">color</span>:skyblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>兄弟元素选择器</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*选择下一个兄弟*/</span></span><br><span class="line"><span class="selector-tag">s</span> + <span class="selector-tag">span</span>&#123;</span><br><span class="line">    <span class="comment">/*选择与p元素的下一个兄弟span元素*/</span></span><br><span class="line">    <span class="attribute">color</span>:wheat;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*选择后面所有的兄弟*/</span></span><br><span class="line"><span class="selector-tag">s</span> ~ <span class="selector-tag">span</span>&#123;</span><br><span class="line">    <span class="comment">/*选择s后面所有的兄弟span元素*/</span></span><br><span class="line">    <span class="attribute">color</span>:thistle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-4属性选择器"><a href="#4-1-4属性选择器" class="headerlink" title="4.1.4属性选择器"></a>4.1.4属性选择器</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[title]</span>&#123;</span><br><span class="line">    <span class="comment">/* 选择含有title属性的元素 */</span></span><br><span class="line">    <span class="attribute">color</span>:blueviolet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[title=abc]</span>&#123;</span><br><span class="line">    <span class="comment">/* 选择含有title属性并且值为purple */</span></span><br><span class="line">    <span class="attribute">color</span>:purple;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[title^=abc]</span>&#123;</span><br><span class="line">    <span class="comment">/* 选择title属性值以abc开头的元素 */</span></span><br><span class="line">    <span class="attribute">color</span>:teal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[title$=abc]</span>&#123;</span><br><span class="line">    <span class="comment">/* 选择title属性以abc结尾的元素 */</span></span><br><span class="line">    <span class="attribute">color</span>:chartreuse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[title*=abc]</span>&#123;</span><br><span class="line">    <span class="comment">/* 选择title属性中含有abc的元素 */</span></span><br><span class="line">    <span class="attribute">color</span>:coral;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-5伪类选择器"><a href="#4-1-5伪类选择器" class="headerlink" title="4.1.5伪类选择器"></a>4.1.5伪类选择器</h3><p>伪类，即不存在的类、特殊的类。用来描述一个元素的特殊状态。如：第一个子元素、被点击的元素、鼠标移入的元素……伪类一般情况下都是以<code>:</code>开头：<br><code>:first-child</code> 第一个子元素<br><code>:last-child</code> 最后一个子元素<br><code>nth-child(1)</code> 选中第1个子元素，<code>nth-child(2)</code> 选中第2个子元素……参数的特殊值见下表<br></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>特殊值</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>n</td>
<td>选中第所有子元素</td>
</tr>
<tr>
<td>2n或者even</td>
<td>选中偶数位的元素</td>
</tr>
<tr>
<td>2n+1或者odd</td>
<td>选中奇数位元素</td>
</tr>
</tbody>
</table>
</div>
<p><code>first-of-type</code> 相同类型的第一个子元素<br><code>last-of-type</code> 相同类型中的最后一个子元素<br><code>nth-of-type</code> 选中相同类型的某个元素</p>
<p><code>:not()</code> 否定伪类，将符合条件的元素从选择器中去除，类似取反</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span>&#123;</span><br><span class="line">    <span class="comment">/* 选中ul元素的第一个子元素 */</span></span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span>&#123;</span><br><span class="line">    <span class="comment">/* 选中ul元素的最后一个子元素 */</span></span><br><span class="line">    <span class="attribute">color</span>:blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(3)</span>&#123;</span><br><span class="line">    <span class="comment">/* 选中ul元素中的第三个子元素 */</span></span><br><span class="line">    <span class="attribute">color</span>:green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:first-of-type</span>&#123;</span><br><span class="line">    <span class="comment">/* 选中li子元素中的第一个子元素 */</span></span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">19px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:last-of-type</span>&#123;</span><br><span class="line">    <span class="comment">/* 选中li子元素中的最后一个子元素 */</span></span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">9px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:nth-of-type(2)</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">29px</span>;</span><br><span class="line">    <span class="comment">/* 选中li子元素中的第二个li子元素 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 否定伪类 */</span></span><br><span class="line"><span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:nth-child(3))</span>&#123;</span><br><span class="line">    <span class="comment">/* 选中除li子元素中的第三个子元素外的li子元素 */</span></span><br><span class="line">    <span class="attribute">color</span>:yellowgreen;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">18px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>超链接的伪类<br></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 超链接的伪类 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>&#123;</span><br><span class="line">    <span class="comment">/* :link表示正常的链接 */</span></span><br><span class="line">    <span class="attribute">color</span>: teal;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span>&#123;</span><br><span class="line">    <span class="comment">/* 用来表示访问过的链接 */</span></span><br><span class="line">    <span class="attribute">color</span>:steelblue;</span><br><span class="line">    <span class="comment">/* 由于考虑到用户的隐私问题，:visited伪类只能设置颜色 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-6伪元素选择器"><a href="#4-1-6伪元素选择器" class="headerlink" title="4.1.6伪元素选择器"></a>4.1.6伪元素选择器</h3><p>伪元素：表示页面中一些特殊的并不真实存在的元素（特殊的位置）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>伪元素</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>::first-letter</code></td>
<td>表示第一个字母</td>
</tr>
<tr>
<td><code>::first-line</code></td>
<td>表示第一行</td>
</tr>
<tr>
<td><code>::selection</code></td>
<td>表示选中的内容</td>
</tr>
<tr>
<td><code>::before</code></td>
<td>元素的开始</td>
</tr>
<tr>
<td><code>::after</code></td>
<td>元素的最后</td>
</tr>
</tbody>
</table>
</div>
<p>注意：before和after必须结合content属性使用，并且其内容是不能被鼠标选中的</p>
<ul>
<li>样式的继承<br>为一个元素设置样式的同时也会应用到它的后代元素上。利用继承可以将一些通用的样式统一设置到共同的祖先元素上，这样只需设置一次即可让所有的元素都具有改样式。并不是所有的样式都会被继承，比如背景相关的，布局等相关的这些样式都不会被继承。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>邢某深知，对于一个普普通通的小捕快，骄傲自满乃是大忌，只有保持一份谦虚谨慎的赤子之心，才能使自己不断进步啊</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是p标签中的p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 子元素p继承了祖先p元素的样式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>样式的冲突<br>当通过不同的选择器，选中相同的元素，并且为相同的样式设置不同的值时，此刻便发生了样式冲突，此时应用哪个样式由选择器的权重决定。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>选择器类型</th>
<th>优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td>内联样式</td>
<td>1,0,0,0</td>
</tr>
<tr>
<td>id选择器</td>
<td>0,1,0,0</td>
</tr>
<tr>
<td>元素选择器</td>
<td>0,0,1,0</td>
</tr>
<tr>
<td>通配选择器</td>
<td>0,0,0,0</td>
</tr>
<tr>
<td>继承的样式</td>
<td>没有优先级</td>
</tr>
</tbody>
</table>
</div>
<p>比较优先级时，需要将所有的选择器的优先级进行相加计算，最后优先级越高，则越优先显示（分组选择器各分组是单独计算的）。<br>选择器的累加不会超过其最大的数量级，类选择器也不会超过id选择器。<br>如果优先级计算之后是相同的，此时则优先使用靠下的样式</p>
<ul>
<li>RGB颜色<br>在CSS中可以直接使用颜色名来设置各种颜色，比如：red、blue、green、yellow等。但这样只能使用一些常见的颜色，并不能覆盖所有的颜色，十分不方便。<br>RGB值：通过三种颜色不同的浓度来调配出不同的颜色，每种颜色的范围在0~255之间。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>RGB值</th>
<th>颜色</th>
</tr>
</thead>
<tbody>
<tr>
<td>rgb(255,0,0)</td>
<td>红色</td>
</tr>
<tr>
<td>rgb(0,255,0)</td>
<td>绿色</td>
</tr>
<tr>
<td>rgb(0,0,255)</td>
<td>蓝色</td>
</tr>
<tr>
<td>rgb(255,255,255)</td>
<td>白色</td>
</tr>
<tr>
<td>rgb(0,0,0)</td>
<td>黑色</td>
</tr>
</tbody>
</table>
</div>
<p>RGBA：在RGB的基础之上增加了一个a表示不透明度，第四个值即表示不透明度（1表示完全不透明，0表示完全透明，.5表示半透明）。rgba(255,123,011,.5)<br>十六进制的RGB：与RGB不同的是，浓度值使用十六进制。如果颜色两位两位重复，可以进行简写：#aabbcc==#abc。<br>HSL值：Hue（色相，0 - 360）、Saturation（饱和度，0% - 100%）、Lightness（亮度，0% - 100%）。hsl(98,48%,40%,0.642)<br></p>
<h1 id="5-布局（Layout）"><a href="#5-布局（Layout）" class="headerlink" title="5.布局（Layout）"></a>5.布局（Layout）</h1><h2 id="5-1文档流"><a href="#5-1文档流" class="headerlink" title="5.1文档流"></a>5.1文档流</h2><p>网页是一个多层结构，一层叠着一层，通过CSS可以位每一层来设置样式，而用户只能看到最顶上一层。这些层中，最底下的一层成为文档流，文档流是网页的基础，创建的元素均是在文档流中进行排列的。<br>对于用户而言，元素有两个状态：在文档流中、不在文档流中（或者叫脱离文档流）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>块元素</th>
<th>行内元素</th>
</tr>
</thead>
<tbody>
<tr>
<td>在页面中独占一行（自上向下垂直排列）<br>默认宽度是父元素的全部（会把父元素撑满）<br>默认高度是被内容撑开（子元素）</td>
<td>不会独占页面的一行，之战自身的大小<br>在页面中自左向右水平排列，且会自动换行到下一行<br>默认宽度和高度都是被内容撑开</td>
</tr>
</tbody>
</table>
</div>
<h2 id="5-2盒子模型（box-model）"><a href="#5-2盒子模型（box-model）" class="headerlink" title="5.2盒子模型（box model）"></a>5.2盒子模型（box model）</h2><p>CSS将页面中的所有元素都设置为一个矩形的盒子。将元素设置为矩形的盒子后，对页面的布局其实就是将不同的盒子摆放到不同的位置。每一个盒子都由以下几个部分组成：<br>内容区（content）、内边距（padding）、外框（border）、外边距（margin）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>组成</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>内容区</td>
<td>相当于盒子里面的物品，存放元素的内容</td>
</tr>
<tr>
<td>内边距</td>
<td>相当于物品与盒子之间的泡沫纸</td>
</tr>
<tr>
<td>外框</td>
<td>相当于盒子的边线</td>
</tr>
<tr>
<td>外边距</td>
<td>盒子与盒子之间的距离</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/boxmodel-(3).png"/></p>
<p>边框三种属性：宽度、颜色、样式（实现or虚线or其他）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">200px</span>;<span class="comment">/*内容区宽度*/</span></span><br><span class="line">            <span class="attribute">height</span>: <span class="number">200px</span>;<span class="comment">/*内容区高度*/</span></span><br><span class="line">            <span class="attribute">background-color</span>: blue;<span class="comment">/*内容区颜色*/</span></span><br><span class="line"></span><br><span class="line">            <span class="attribute">border-width</span>: <span class="number">10px</span>;<span class="comment">/*边框宽度，1个值时四边均为10px*/</span></span><br><span class="line">            <span class="comment">/* 其他值时的情况 */</span></span><br><span class="line">            <span class="attribute">border-width</span>: <span class="number">10px</span> <span class="number">20px</span> <span class="number">30px</span> <span class="number">40px</span>;<span class="comment">/*4个值时，上10px 右20px 下30px 左40px(即顺时针方向)*/</span></span><br><span class="line">            <span class="attribute">border-width</span>: <span class="number">10px</span> <span class="number">20px</span> <span class="number">30px</span>;<span class="comment">/*3个值时，上10px，左右20px，下30px*/</span></span><br><span class="line">            <span class="attribute">border-width</span>: <span class="number">10px</span> <span class="number">20px</span>;<span class="comment">/*2个值时，上下10px，左右20px*/</span></span><br><span class="line">            <span class="comment">/*也可单独设置*/</span></span><br><span class="line">            <span class="comment">/* border-top-width: 10px;</span></span><br><span class="line"><span class="comment">            border-right-width: 20px;</span></span><br><span class="line"><span class="comment">            border-bottom-width: 30px;</span></span><br><span class="line"><span class="comment">            border-left-width: 40px; */</span></span><br><span class="line"></span><br><span class="line">            <span class="attribute">color</span>:tomato;</span><br><span class="line">            <span class="attribute">border-color</span>: aqua;<span class="comment">/*也可单独设置，默认值为color值，若没有color，则默认是黑色（因为color默认值即为黑色）*/</span></span><br><span class="line">            <span class="attribute">border-style</span>: solid;<span class="comment">/*也可单独设置，默认值是none，即没有边框*/</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*以下这种简单的写法更常用，三者没有顺序*/</span></span><br><span class="line">            <span class="attribute">border</span>: aqua solid <span class="number">20px</span>;</span><br></pre></td></tr></table></figure>
<p>padding和margin设置同上。<br/>相邻的垂直方向外边距会发生重叠现象：兄弟元素间的响铃垂直外边距会取两者之间的较大值</p>
<p>进度P57，未完待续……</p>
]]></content>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础语法</title>
    <url>/2021/02/04/Java_Basics/</url>
    <content><![CDATA[<p>此前学习了C语言，思维仍是面向过程的编程思想。现在开始学习Java，转变一下思路。特此写博客记录Java的知识点。关于编程语言中的一些通用的重复性内容就不再赘述，在此文中提及的前面的一些基础，都是当时学习C语言时候自己埋下的坑，都是自己的血泪！！！</p>
<p>此篇博客未完待续……</p>
<a id="more"></a>
<p><a href="#bottom">到达文章底部</a></p>
<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><h2 id="1-1-语言的特点"><a href="#1-1-语言的特点" class="headerlink" title="1.1 语言的特点"></a>1.1 语言的特点</h2><p>1.面向对象两个基本概念：类、对象；三大特性：封装、继承、多态；<br>2.健壮性去除了C/C++中的影响健壮性的指针内存的申请与释放等，提供一个相对安全的内存管理和访问机制垃圾回收机制（但是仍然会出现内存溢出和内存泄露的问题）<br>3.跨平台性一次编译，多次运行（Write once，run anywhere）。原理为：在需要运行Java的应用程序的操作系统上，先安装Java虚拟机即可。由虚拟机来负责Java程序在系统中的运行。</p>
<h2 id="1-2-java的两种核心机制"><a href="#1-2-java的两种核心机制" class="headerlink" title="1.2 java的两种核心机制"></a>1.2 java的两种核心机制</h2><p>虚拟机机制（Java Virtual Machine）、垃圾回收机制（Garbage Collection）</p>
<h2 id="1-3-JDK、JRE、JVM"><a href="#1-3-JDK、JRE、JVM" class="headerlink" title="1.3 JDK、JRE、JVM"></a>1.3 JDK、JRE、JVM</h2><p>JDK=JRE + 开发工具集（例如javac编译工具等）；JRE=JVM + JavaSE标准类库</p>
<h1 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2. 基本语法"></a>2. 基本语法</h1><h2 id="2-1-关键字、保留字、标识符"><a href="#2-1-关键字、保留字、标识符" class="headerlink" title="2.1 关键字、保留字、标识符"></a>2.1 关键字、保留字、标识符</h2><p>1.关键字：过多，使用时记忆<br>2.保留字：现有JAVA版本尚未使用名，但是以后版本可能会作为关键字使用，因此命名标识符时需要避免使用这些保留字：const、goto<br>3.标识符：变量名、方法名、类名、接口名、包名等凡是自己可以命名的都叫标识符，命名时JAVA是严格区分大小写的</p>
<h2 id="2-2-命名规范"><a href="#2-2-命名规范" class="headerlink" title="2.2 命名规范"></a>2.2 命名规范</h2><ul>
<li>包名：所有单词小写”xxyyzz”</li>
<li>类名、接口名：每个单词的首字母大写（大驼峰命名）”XxYyZz”</li>
<li>变量名、方法名：第一个单词小写，后面的单词每个单词首字母大写（小驼峰命名）”xxYyZz”</li>
<li>常量名：所有字母大写，多个单词时用下划线连接”XX_YY_ZZ”</li>
</ul>
<h2 id="2-3-变量的分类"><a href="#2-3-变量的分类" class="headerlink" title="2.3 变量的分类"></a>2.3 变量的分类</h2><p>按照基本数据类型分：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/变量的分类-按数据类型.svg" alt="变量的分类-按数据类型"></p>
<p>按照声明的位置不同分：</p>
<center><img alt="变量的分类-按照声明的位置" src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/变量的分类-按声明的位置.svg"></center>

<p>下面介绍按照基本数据类型分类的变量。</p>
<h3 id="2-3-1-基本数据类型（primitive-type）"><a href="#2-3-1-基本数据类型（primitive-type）" class="headerlink" title="2.3.1 基本数据类型（primitive type）"></a>2.3.1 基本数据类型（primitive type）</h3><p>1.整型（byte、short、int、long）：整型常量默认为 int 型</p>
<p>2.浮点型（float、double）：浮点型常量默认为 double 型，定义 long 和 float 类型初始化及赋值时需要在数值后面加上 “L” 或 “l” 和 “F” 或 “f”，常用 int 和 double 类型。若 long 型不加上后缀，则默认为 int 型，而 float 类型必须加上后缀，否则编译报错；</p>
<p>3.字符型（char）：与C不同，java的字符型 char可以表示任何一个字符（每个字符占2个字节），而不单单是西文字符，如<code>char a = &#39;我&#39;;</code>，而<code>char a = &#39;48&#39;;</code>是错误的，因为 <code>&#39;48&#39;</code>是2个字符，哪怕是<code>&#39;4空格&#39;</code>也不行，空格也算一个字符，但是<code>char a = 48;</code>是对的，因为没有用单引号括起来时，相当于将 ASCII 码值给ａ，编译时机器会查表将其替换成对应的字符。128 个 ASCII 码字符用8位表示，最高位规定为0，剩下7位表示0~127的 ASCII 码字符；</p>
<p>4.布尔型（boolean）</p>
<h3 id="2-3-2-引用数据类型（reference-type）"><a href="#2-3-2-引用数据类型（reference-type）" class="headerlink" title="2.3.2 引用数据类型（reference type）"></a>2.3.2 引用数据类型（reference type）</h3><p>class（类）、interface（接口）、array（数组）</p>
<h3 id="2-3-3-数据类型转换（不包括boolean）"><a href="#2-3-3-数据类型转换（不包括boolean）" class="headerlink" title="2.3.3 数据类型转换（不包括boolean）"></a>2.3.3 数据类型转换（不包括boolean）</h3><p>1.自动类型提升当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。即  byte、char、short → int → long → float → double特别地，当byte、char、short 三种类型的变量做运算时，结果为 int 型<br>2.强制类型转换（自动类型提升的逆运算）</p>
<h2 id="2-4-运算符"><a href="#2-4-运算符" class="headerlink" title="2.4 运算符"></a>2.4 运算符</h2><ul>
<li>自增自减以及 += 和 -= 不会改变数据类型，如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">short</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/******************************************************************/</span></span><br><span class="line"><span class="comment">//a = a + 1；</span></span><br><span class="line"><span class="comment">/*此处a+1的结果自动转换成了int型，但是接收的a为short。C中只是警告，但是编译可以通过，自动将结果强制转换成short,而java中则不能通过编译*/</span></span><br><span class="line"><span class="comment">/******************************************************************/</span></span><br><span class="line">a += <span class="number">1</span>;</span><br><span class="line"><span class="comment">//a++;</span></span><br><span class="line"><span class="comment">//++a;</span></span><br><span class="line"><span class="comment">//自增自减不会修改本身的数据类型，因此是可以在C和java通过编译,且都没有警告</span></span><br><span class="line"><span class="comment">/******************************************************************/</span></span><br><span class="line">System.out.println(a);<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>最新标准的 java 和 C 中自增自减的区别</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">short</span> a = <span class="number">1</span>;</span><br><span class="line">a += (a++) + (++a);<span class="comment">//此类“谭++”式表达式虽然毫无意义，甚至有点反人类，但是考试经常考</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C中先计算右边内容：1+(2+1)=4，此时由于(++a)的自增，a=3；然后进行a = a + 4的计算，所以最后结果a = 7</span></span><br><span class="line"><span class="comment">java中同样是先计算右边的内容：1+(2+1)=4，但是a的值不会因为自增而改变，仍然a = 1，然后直接进行a = a + 4的计算，结果a = 5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.out.println(a);<span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>逻辑运算符（操作对象必须是 boolean 型）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C中只有&amp;&amp;、||、!（即与、或、非）三种逻辑运算符（操作对象可以是任何基本数据类型，只对值进行判断：0即为假，非0即为真）</span></span><br><span class="line"><span class="comment">java中有&amp;、|、&amp;&amp;、||、!、^（即逻辑与、逻辑或、短路与、短路或、逻辑非、逻辑异或）6种逻辑运算符，前面四种也可称单与、双与和单或、双或</span></span><br><span class="line"><span class="comment">java逻辑运算符中的&amp;、|不管前面的表达式如何，都会执行后面的表达式（比较笨），而C中无此类的逻辑运算符</span></span><br><span class="line"><span class="comment">而逻辑运算符有短路情况，即前面的表达式可以得到最终结果时，后面的表达式将不被执行（比较聪明，节省了运行时间），反之执行；在这一点上，C中的&amp;&amp;、||与java相同；</span></span><br><span class="line"><span class="comment">因此一般开发都使用&amp;&amp;、||，|和&amp;多出现在考试中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//下面以&amp;和&amp;&amp;为例，|和||类似</span></span><br><span class="line"><span class="keyword">boolean</span> judgement1 = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> number1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(judgement1 &amp; (number1++ &gt; <span class="number">0</span>))</span><br><span class="line">System.out.println(number1);<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> judgement2 = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> number2 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(judgement2 &amp;&amp; (number2++ &gt; <span class="number">0</span>))</span><br><span class="line">System.out.println(number2);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>位运算符（实用很少，但是考试会有相关的题目）：左移操作&lt;&lt;，低位补0（多出的高位丢弃）；右移操作&gt;&gt;，高位补符号位（符号位为何值，就补何值）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注：所有的位运算都是对补码进行操作的，且符号位不参与移位</span></span><br><span class="line"><span class="comment">//左移操作</span></span><br><span class="line"><span class="comment">//①</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">44</span>;</span><br><span class="line"><span class="keyword">int</span> b = a &lt;&lt; <span class="number">2</span>;</span><br><span class="line">System.out.println(b);</span><br><span class="line"><span class="comment">//0 000 0000 0010 1100		44</span></span><br><span class="line"><span class="comment">//0 000 0000 1011 0000		结果176</span></span><br><span class="line"><span class="comment">//②</span></span><br><span class="line"><span class="keyword">int</span> c = -<span class="number">8319</span>;</span><br><span class="line"><span class="keyword">int</span> d = c &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="comment">//1 010 0000 0111 1111		原码-8319</span></span><br><span class="line"><span class="comment">//1 101 1111 1000 0001		补码-8319</span></span><br><span class="line"><span class="comment">//1 111 1110 0000 0100		左移结果（补码）</span></span><br><span class="line"><span class="comment">//1 000 0001 1111 1100		左移结果（原码）-33276</span></span><br><span class="line">System.out.println(d);<span class="comment">//-33276</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//右移操作</span></span><br><span class="line"><span class="keyword">int</span> e = -<span class="number">36</span>;</span><br><span class="line"><span class="keyword">int</span> f = e &gt;&gt; <span class="number">2</span>;</span><br><span class="line"><span class="comment">//1 000 0000 0010 0100		原码-36</span></span><br><span class="line"><span class="comment">//1 111 1111 1101 1100		补码-36</span></span><br><span class="line"><span class="comment">//1 111 1111 1111 0111		右移结果（补码）</span></span><br><span class="line"><span class="comment">//1 000 0000 0000 1001		右移结果（原码）-9</span></span><br><span class="line">System.out.println(f);<span class="comment">//-9</span></span><br></pre></td></tr></table></figure>
<ul>
<li>比较运算符<code>instanceof</code>判断对象是否是一个类</li>
</ul>
<p>下面是产生随机数的一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> Test1 = Math.random();</span><br><span class="line">        <span class="comment">//Math类中的random方法返回一个[0.0,1.0)之间的随机数</span></span><br><span class="line">        <span class="keyword">double</span> Test2 = Math.random() * <span class="number">90</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//通过式子处理，产生[10.0,100.0)之间的随机数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> value = (<span class="keyword">int</span>)(Math.random() * <span class="number">90</span> + <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//通过强制转换，产生[10,100)之间的整数即[10,99]</span></span><br><span class="line">        System.out.println(value);</span><br><span class="line">        <span class="comment">//由上不难得出产生任意范围[a,b]内的随机整数公式:</span></span><br><span class="line">        <span class="comment">//(int)(Math.random()*(b - a + 1) + a)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-5-switch-case语句"><a href="#2-5-switch-case语句" class="headerlink" title="2.5 switch-case语句"></a>2.5 switch-case语句</h2><p>与C不同，java中的的switch(variable)中的变量variable可以为以下6种数据类型之一：byte、short、char、int、枚举类型( JDK 5.0新增)、String( JDK 7.0新增)，而C中的只能为整型。</p>
<h2 id="2-6-break和continue关键字"><a href="#2-6-break和continue关键字" class="headerlink" title="2.6 break和continue关键字"></a>2.6 break和continue关键字</h2><p>break默认结束当前循环，可用于循环语句和switch-case语句；continue默认只结束当前循环的本次循环，且continue只能用于循环语句。两者相同点是：同一层次位置处，其后面不能有执行语句，否则编译报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标签的使用（java中有，C中没有）</span></span><br><span class="line">label:<span class="keyword">for</span>(......)&#123;</span><br><span class="line">    <span class="keyword">for</span>(......)&#123;</span><br><span class="line">        <span class="keyword">break</span> label;<span class="comment">//结束label标签处的当前循环</span></span><br><span class="line">        <span class="comment">//continue label;//结束label标签处的外层循环的本次循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-数组"><a href="#3-数组" class="headerlink" title="3. 数组"></a>3. 数组</h1><blockquote>
<p>数组属于引用数据类型，而数组的元素可以是任何数据类型</p>
</blockquote>
<h2 id="3-1-一维数组"><a href="#3-1-一维数组" class="headerlink" title="3.1 一维数组"></a>3.1 一维数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneDimensionalArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.数组静态初始化</span></span><br><span class="line">        <span class="keyword">int</span>[] array1_1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;<span class="comment">//引用类型初始化都需要借助new</span></span><br><span class="line">        String[] array1_2 = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;川建国&quot;</span>,<span class="string">&quot;拜振华&quot;</span>,<span class="string">&quot;FakeNews&quot;</span>,<span class="string">&quot;China&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.数组动态初始化</span></span><br><span class="line">        <span class="keyword">int</span>[] array2_1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        String[] array2_2 = <span class="keyword">new</span> String[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        System.out.println(array2_1.length);<span class="comment">//length属性返回数组的长度</span></span><br><span class="line">        <span class="comment">//数组一旦初始化，便确定了长度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//要求：输入学生人数及分数，根据分数与最高分之间的差值来评级：</span></span><br><span class="line">        <span class="comment">//[0,10)为A，[10,20)为B，[20,30)为C，[30,maxScore]为D</span></span><br><span class="line">        System.out.println(<span class="string">&quot;输入人数：&quot;</span>);</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> number = scan.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] score = <span class="keyword">new</span> <span class="keyword">int</span>[number];</span><br><span class="line">        <span class="keyword">int</span> maxScore = score[<span class="number">0</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;输入分数：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; score.length; index++) &#123;</span><br><span class="line">            score[index] = scan.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (maxScore &lt; score[index]) &#123;</span><br><span class="line">                maxScore = score[index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;最高分maxScore = &quot;</span> + maxScore);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; score.length; index++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxScore - score[index] &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;学生&quot;</span> + index + <span class="string">&quot;的分数等级为：&quot;</span> + <span class="string">&quot;A&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxScore - score[index] &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;学生&quot;</span> + index + <span class="string">&quot;的分数等级为：&quot;</span> + <span class="string">&quot;B&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxScore - score[index] &lt; <span class="number">30</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;学生&quot;</span> + index + <span class="string">&quot;的分数等级为：&quot;</span> + <span class="string">&quot;C&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxScore - score[index] &lt;= maxScore) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;学生&quot;</span> + index + <span class="string">&quot;的分数等级为：&quot;</span> + <span class="string">&quot;D&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在遍历数组时，可以使用增强for循环（JDK1.5新增）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用普通for循环实现</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =  <span class="number">0</span> ; i &lt; arr.length ; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;元素：&quot;</span>+ arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用增强for循环实现 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ints : arr)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;元素：&quot;</span>+ ints);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>不同类型的数组元素的默认初始化值不同</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">元素类型</th>
<th style="text-align:center">初始化值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">整型（byte、short、char、int、long）</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:left">浮点型（float、double）</td>
<td style="text-align:center">0.0</td>
</tr>
<tr>
<td style="text-align:left">字符型（char）</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:left">布尔型（boolean）</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:left">引用数据类型（class、interface、array）</td>
<td style="text-align:center">null</td>
</tr>
</tbody>
</table>
</div>
<h2 id="3-2-二维数组"><a href="#3-2-二维数组" class="headerlink" title="3.2 二维数组"></a>3.2 二维数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoDimensionalArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.静态初始化</span></span><br><span class="line">        <span class="keyword">int</span>[][] array1 = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.动态初始化</span></span><br><span class="line">        <span class="keyword">int</span>[][] array2_1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span>[][] array2_2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line">        System.out.println(arr);<span class="comment">//[[I@1b6d3586，“[[”代表二维数组，“I”代表int型，@后面的数表示地址值</span></span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);<span class="comment">//[I@4554617c</span></span><br><span class="line">        System.out.println(arr[<span class="number">0</span>][<span class="number">0</span>]);<span class="comment">//0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-数组中涉及的常见算法"><a href="#3-3-数组中涉及的常见算法" class="headerlink" title="3.3 数组中涉及的常见算法"></a>3.3 数组中涉及的常见算法</h2><h3 id="3-3-1-数组元素的赋值（杨辉三角、回形数等）"><a href="#3-3-1-数组元素的赋值（杨辉三角、回形数等）" class="headerlink" title="3.3.1 数组元素的赋值（杨辉三角、回形数等）"></a>3.3.1 数组元素的赋值（杨辉三角、回形数等）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">//以杨辉三角为例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YangHuiTriangle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用二维数组打印杨辉三角</span></span><br><span class="line">        System.out.print(<span class="string">&quot;输入行数：&quot;</span>);</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> column = scan.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[][] yangHui = <span class="keyword">new</span> <span class="keyword">int</span>[column][];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; yangHui.length;i++)&#123;</span><br><span class="line">            yangHui[i] = <span class="keyword">new</span> <span class="keyword">int</span>[i + <span class="number">1</span>];<span class="comment">//第i行有（i+1）列</span></span><br><span class="line">            yangHui[i][<span class="number">0</span>] = yangHui[i][i] = <span class="number">1</span>;<span class="comment">//每行第一个和最后一个赋值0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//给每行的非行首行尾的元素赋值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; yangHui[i].length - <span class="number">1</span>;j++)&#123;</span><br><span class="line">                yangHui[i][j] = yangHui[i-<span class="number">1</span>][j-<span class="number">1</span>] + yangHui[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历二维数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; yangHui.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; yangHui[i].length;j++)&#123;</span><br><span class="line">                System.out.print(yangHui[i][j] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-2-求数组元素的最大值、最小值、总和、平均值"><a href="#3-3-2-求数组元素的最大值、最小值、总和、平均值" class="headerlink" title="3.3.2 求数组元素的最大值、最小值、总和、平均值"></a>3.3.2 求数组元素的最大值、最小值、总和、平均值</h3><h3 id="3-3-3-数组元素的查找"><a href="#3-3-3-数组元素的查找" class="headerlink" title="3.3.3 数组元素的查找"></a>3.3.3 数组元素的查找</h3><p>1.线性查找（按顺序查找）<br>2.二分法查找（折半查找）：使用前提是<font color= "red">有序（升降序都行）的数据</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">18</span>, -<span class="number">9</span>, <span class="number">12</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">45</span>, <span class="number">78</span>, <span class="number">90</span>, <span class="number">99</span>, <span class="number">123</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = array.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入需要查找的值：&quot;</span>);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> number = scanner.nextInt();</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (head &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (head + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (number == array[middle]) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;找到了指定的元素，索引位置为：&quot;</span> + middle);</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (number &gt; array[middle]) &#123;</span><br><span class="line">                head = middle + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;很遗憾，没有找到该元素值&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-4-数组元素的排序算法"><a href="#3-3-4-数组元素的排序算法" class="headerlink" title="3.3.4 数组元素的排序算法"></a>3.3.4 数组元素的排序算法</h3><p>下面以冒泡法为例，其他的排序算法暂时不提</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">12</span>, -<span class="number">9</span>, <span class="number">123</span>, <span class="number">121</span>, <span class="number">90</span>, <span class="number">65</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="number">19</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    temp = array[j];</span><br><span class="line">                    array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                    array[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.print(array[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-关于数组的Arrays类的常用方法"><a href="#3-4-关于数组的Arrays类的常用方法" class="headerlink" title="3.4 关于数组的Arrays类的常用方法"></a>3.4 关于数组的Arrays类的常用方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;f</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraysTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Arrays类中的常用方法</span></span><br><span class="line">        <span class="comment">//1.boolean equals(int[] a,int[] b)比较两数组是否相等（元素值是否相等）</span></span><br><span class="line">        <span class="keyword">int</span>[] array1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] array2 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">boolean</span> isEqual = Arrays.equals(array1,array2);</span><br><span class="line">        System.out.println(isEqual);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.String toString(int[] a)输出数组信息</span></span><br><span class="line">        System.out.println(Arrays.toString(array1));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.void fill(int[] a,int val)将指定值填充到数组中</span></span><br><span class="line">        Arrays.fill(array2,<span class="number">10</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.void sort(int[] a)对数组进行排序</span></span><br><span class="line">        <span class="keyword">int</span>[] array3 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">12</span>, -<span class="number">9</span>, <span class="number">123</span>, <span class="number">121</span>, <span class="number">90</span>, <span class="number">65</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="number">19</span>&#125;;</span><br><span class="line">        Arrays.sort(array3);</span><br><span class="line">        System.out.println(Arrays.toString(array3));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.int binarySearch(int[] a,int key)查找数组中元素的索引</span></span><br><span class="line">        <span class="keyword">int</span>[] array4 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">12</span>, -<span class="number">9</span>, <span class="number">123</span>, <span class="number">121</span>, <span class="number">90</span>, <span class="number">65</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="number">19</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> index1 = Arrays.binarySearch(array3,<span class="number">121</span>);</span><br><span class="line">        <span class="keyword">int</span> index2 = Arrays.binarySearch(array3,<span class="number">122</span>);</span><br><span class="line">        System.out.println(index1);</span><br><span class="line">        System.out.println(index2);<span class="comment">//若没有找到，则返回负数，具体是负多少，需查看该方法的源码</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-面向对象编程（上）"><a href="#4-面向对象编程（上）" class="headerlink" title="4. 面向对象编程（上）"></a>4. 面向对象编程（上）</h1><blockquote>
<p>面向对象的3条主线：</p>
<p>1.Java类及类的成员：属性、方法、构造器；代码块、内部类</p>
<p>2.面向对象的三大特征：封装性、继承性、多态性、（抽象性）</p>
<p>3.关键字：this、super、static、final、abstract、interface、package、import</p>
</blockquote>
<h2 id="4-1-类和对象"><a href="#4-1-类和对象" class="headerlink" title="4.1 类和对象"></a>4.1 类和对象</h2><blockquote>
<p>类：对一类事物的描述，是抽象的、概念上的定义；</p>
<p>对象：实际存在的该类事物的每个个体，因而可以说是类的实例（instance）；</p>
<p>匿名对象：不需要创建一个对象去接收new出来的引用类型，或者说创建对象时没有显示地赋给一个变量名，这样即为匿名对象。但是，匿名对象只能使用1次，调用完之后便会被回收掉。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Student().height = <span class="number">176</span>;</span><br><span class="line">System.out.println(<span class="keyword">new</span> Student().height);<span class="comment">//结果为0，因为上一句的new Student()的匿名对象在使用完之后便被回收了</span></span><br></pre></td></tr></table></figure>
<p>只有在传入形参等只需要使用1次对象的时候才会被采用。<font color="red">面向对象程序设计的重点是类的设计，而设计类，就是设计类的成员</font>，一段示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        p1.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">        p1.isMale = <span class="keyword">true</span>;</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(p2.name);</span><br><span class="line">        Person p3 = p1;</span><br><span class="line">        p3.age = <span class="number">10</span>;</span><br><span class="line">        System.out.println(p1.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">boolean</span> isMale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述关于对象的代码的内存解析如下：<img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210219173927212.png" alt="image-20210219173927212"></p>
<p>关于对象数组代码的内存解析如下：</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210219180938556.png" alt="image-20210219180938556"></p>
<p>stus数组元素都是student类型（即引用类型），所以数组成员在没有初始化时（new创建对象）默认为null。若此时将其属性值打印出来<code>System.out.println(stus[1].number);</code>，那么便会报错，为空指针异常。因为null不会指向任何地址，无法读出值。只有初始化数组成员即<code>stus[1] = new Student();</code>之后才能读出改成员的属性。</p>
<h2 id="4-2-属性（或称-“成员变量”-）与局部变量的区别"><a href="#4-2-属性（或称-“成员变量”-）与局部变量的区别" class="headerlink" title="4.2 属性（或称 “成员变量” ）与局部变量的区别"></a>4.2 属性（或称 “成员变量” ）与局部变量的区别</h2><blockquote>
<p> 属性：直接定义在类的一对 {} 内</p>
<p>局部变量：<font color="red">声明</font>在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</p>
</blockquote>
<p>区别如下：<br>1.权限修饰符可以在声明属性时，使用权限修饰符指明其权限。常用权限修饰符：private、public、protected、缺省（就是不写）。但是局部变量不能用权限修饰符修饰，否则编译不通过；</p>
<p>2.默认初始化值局部变量没有默认的初始化值，因此在调用局部变量时，一定要显式赋值（调用形参时赋值即可）。属性默认的初始化值如下（与数组元素的默认初始化值相同）：<img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210219174910851.png" alt="image-20210219174910851"></p>
<p>但是属性初始化之后便不能在造器外部类内部被赋值。</p>
<p>3.内存中加载的位置属性加载到堆空间中（非static）。堆内变量在没有栈内变量的指向时，会被垃圾回收器回收。局部变量加载到栈空间中，在方法结束后，局部变量出栈。</p>
<h2 id="4-3-方法"><a href="#4-3-方法" class="headerlink" title="4.3 方法"></a>4.3 方法</h2><h3 id="4-3-1-方法的重载（overload）"><a href="#4-3-1-方法的重载（overload）" class="headerlink" title="4.3.1 方法的重载（overload）"></a>4.3.1 方法的重载（overload）</h3><p>在同一个类中，允许存在一个以上的同名（返回值类型不同也可）方法，只要它们的参数个数或者参数类型不同即可，那么这些重名的两个或两个以上的方法之间就是方法重载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">下列方法是否与<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">char</span> b,<span class="keyword">double</span> c)</span></span>&#123;&#125;构成方法重载</span><br><span class="line"></span><br><span class="line">a)<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">char</span> y,<span class="keyword">double</span> z)</span></span>&#123;&#125;<span class="comment">//no，因为尽管形参名字不同，但是形参类型都是一致的</span></span><br><span class="line"></span><br><span class="line">b)<span class="function"><span class="keyword">int</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">double</span> c,<span class="keyword">char</span> b)</span></span>&#123;&#125;<span class="comment">//yes，因为两者的形参列表的顺序不同</span></span><br><span class="line"></span><br><span class="line">c)<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">double</span> c,<span class="keyword">char</span> b)</span></span>&#123;&#125;<span class="comment">//yes，同上</span></span><br><span class="line"></span><br><span class="line">(b)和(c)之间并不构成方法重载，两者完全一致，但是返回值类型不同，会产生歧义</span><br><span class="line"></span><br><span class="line">d)<span class="function"><span class="keyword">boolean</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">char</span> b)</span></span>&#123;&#125;<span class="comment">//yes，参数列表不同</span></span><br><span class="line"></span><br><span class="line">e)<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">double</span> c)</span></span>&#123;&#125;<span class="comment">//yes，同上</span></span><br><span class="line"></span><br><span class="line">f)<span class="function"><span class="keyword">double</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">char</span> y,<span class="keyword">double</span> z)</span></span>&#123;&#125;<span class="comment">//no，形参类型一致</span></span><br><span class="line"></span><br><span class="line">g)<span class="function"><span class="keyword">void</span> <span class="title">shows</span><span class="params">()</span></span>&#123;<span class="keyword">double</span> c;&#125;<span class="comment">//no，方法名字都不一样</span></span><br></pre></td></tr></table></figure>
<h3 id="4-3-2-可变个数的形参"><a href="#4-3-2-可变个数的形参" class="headerlink" title="4.3.2 可变个数的形参"></a>4.3.2 可变个数的形参</h3><p>JavaSE 5.0中提供了Varargs(Variable number of arguments)机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。<br>JDK5.0以前：采用数组形参来定义方法，传入多个同一类型变量public static void test(int a ,String[]books);<br>JDK5.0：采用可变个数形参来定义方法，传入多个同一类型变量public static void test(int a ,String…books);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,String[] books)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span>[] books)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,String... books)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span>... books)</span></span>;</span><br></pre></td></tr></table></figure>
<p>传入的参数可以是：0，1，2，3…….。但是，可变个数形参在方法的形参中必须声明在末尾，并且最多只能声明一个可变形参。上述两个方法之间并不构成方法重载，两者恰恰是完全相同的。</p>
<h3 id="4-3-4-方法参数的值传递机制"><a href="#4-3-4-方法参数的值传递机制" class="headerlink" title="4.3.4 方法参数的值传递机制"></a>4.3.4 方法参数的值传递机制</h3><p>java中方法的参数传递方式只有一种：值传递。即将实际参数的副本（复制品）传入方法内，而参数本身不受影响。当形参是基本数据类型，则传递基本数据类型的<font color="red">数据值</font>；当形参是引用数据类型，则传递引用数据类型变量的<font color="red">地址值</font>。</p>
<h3 id="4-3-5-递归（recursion）方法"><a href="#4-3-5-递归（recursion）方法" class="headerlink" title="4.3.5 递归（recursion）方法"></a>4.3.5 递归（recursion）方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归求和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n + getSum(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归求斐波那契数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciSequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        System.out.print(<span class="string">&quot;n = &quot;</span>);</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = input.nextInt();</span><br><span class="line"></span><br><span class="line">        FibonacciSequence test = <span class="keyword">new</span> FibonacciSequence();</span><br><span class="line">        <span class="comment">//前n项斐波那契数列存到数组arr中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            arr[i] = test.function(arr,i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;前&quot;</span> + n + <span class="string">&quot;项斐波那契数列如下：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*利用递归，创建方法求出斐波那契数列的某一项的值*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">function</span> <span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> arr[n-<span class="number">1</span>] + arr[n-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-4-面向对象特征"><a href="#4-4-面向对象特征" class="headerlink" title="4.4 面向对象特征"></a>4.4 面向对象特征</h2><h3 id="4-4-1-权限修饰符"><a href="#4-4-1-权限修饰符" class="headerlink" title="4.4.1 权限修饰符"></a>4.4.1 权限修饰符</h3><p>Java规定的4种权限（从小打大）：<code>private</code>、缺省（就是不写）、<code>protected</code>、<code>public</code>置于<font color="red">类的成员（属性、方法、构造器、内部类）</font>定义前，用来限制对象对该类成员的访问权限。而class类只能被<code>public</code>、缺省修饰。<code>public</code>类可以在任意地方被访问；缺省类只可以被同一个包的类之间访问。修饰符的访问权限如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">类内部</th>
<th style="text-align:center">同一个包的不同类</th>
<th style="text-align:center">不同包的子类</th>
<th style="text-align:center">同一个工程（含多个包）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>private</code></td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:center">缺省（就是不写）</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:center"><code>protected</code></td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:center"><code>public</code></td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
</tr>
</tbody>
</table>
</div>
<p>关于权限修饰符，在<a href="#5.3">5.3 四种权限修饰符</a>中还作了进一步补充说明。</p>
<h3 id="4-4-2-封装性Encapsulation（面向对象的特征之一）"><a href="#4-4-2-封装性Encapsulation（面向对象的特征之一）" class="headerlink" title="4.4.2 封装性Encapsulation（面向对象的特征之一）"></a>4.4.2 封装性<code>Encapsulation</code>（面向对象的特征之一）</h3><blockquote>
<p>当创建一个类的对象后，可以通过<code>对象.属性</code>或<code>对象.方法</code>的方式进行初始化。但是，在实际问题中，往往需要给属性添加限制条件（如动物的腿的数一般都是偶数even number）。然而这个限制条件就无法在属性声明时设置，只能通过在该类中创建方法添加限制条件而不用对象调用属性。同时，为了避免<font color="red">既使用方法设置限制条件，又通过对象调用设置限制条件</font>的混乱情况，使用<code>private</code>关键字将属性或者方法声明为私有的。</p>
</blockquote>
<p><strong>封装性的体现1：</strong>将类的属性<code>xxx</code>使用<code>private</code>私有化，同时，提供公共的方法（即public修饰的）来获取（<code>getXxx</code>）和设置（<code>setXxx</code>）此属性的值；<br><strong>封装性的体现2：</strong>不对外暴露私有的方法；<br><strong>封装性的体现3：</strong>单例模式（将构造器私有化）；<br><strong>封装性的体现4：</strong>如果不希望类在包外被调用，可以将类设置为缺省的。</p>
<h2 id="4-5-构造器（或构造方法，constructor）"><a href="#4-5-构造器（或构造方法，constructor）" class="headerlink" title="4.5 构造器（或构造方法，constructor）"></a>4.5 构造器（或构造方法，constructor）</h2><h3 id="4-5-1-构造器的特征"><a href="#4-5-1-构造器的特征" class="headerlink" title="4.5.1 构造器的特征"></a>4.5.1 构造器的特征</h3><p>具有与类相同的名称、不声明返回值类型（与声明为void不同）、不被<code>static</code>、<code>final</code>、<code>synchronized</code>、<code>abstract</code>、<code>native</code>修饰，不能用return语句返回值。</p>
<h3 id="4-5-2-构造器的作用"><a href="#4-5-2-构造器的作用" class="headerlink" title="4.5.2 构造器的作用"></a>4.5.2 构造器的作用</h3><p><strong>创建对象（最核心的作用），</strong>如：<code>Order o = new Order();</code><br>在创建对象时对属性初始化，如：<code>Person p = Person(&quot;Peter&quot;,15);</code></p>
<h3 id="4-5-3-说明"><a href="#4-5-3-说明" class="headerlink" title="4.5.3 说明"></a>4.5.3 说明</h3><p>1.如果没有显式地定义类的构造器的话，则系统默认提供一个空参构造器，因此一个类至少有一个构造器；<br>2.定义构造器的格式：<code>权限修饰符 类名(形参列表)&#123;&#125;</code>；<br>3.一个类中定义的多个构造器，彼此构成重载；<br>4.一旦显式地定义了类的构造器之后，系统就不再提供默认的空参构造器；<br>5.构造器只有在构造器内才能被调用，其他地方禁止调用构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//        编写两个类，TriAngle和Constructor</span></span><br><span class="line"><span class="comment">//        其中TriAngle类中声明私有的底边长base和高height，同时声明公共方法访问私有变量。此外，提供类必要的构造器</span></span><br><span class="line"><span class="comment">//        Constructor类中使用这些公共方法，计算三角形的面积</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Constructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TriAngle angle1 = <span class="keyword">new</span> TriAngle();</span><br><span class="line">        angle1.setBase(<span class="number">3.0</span>);</span><br><span class="line">        angle1.setHeight(<span class="number">4.9</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;base = &quot;</span> + angle1.getBase() + <span class="string">&quot;\theight = &quot;</span> + angle1.getHeight() + <span class="string">&quot;\tarea = &quot;</span> + angle1.area());</span><br><span class="line"></span><br><span class="line">        TriAngle angle2 = <span class="keyword">new</span> TriAngle(<span class="number">2.0</span>,<span class="number">3.1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;base = &quot;</span> + angle2.getBase() + <span class="string">&quot;\theight = &quot;</span> + angle2.getHeight() + <span class="string">&quot;\tarea = &quot;</span> + angle2.area());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TriAngle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> base;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    通过声明公共的方法访问私有变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBase</span><span class="params">(<span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">        base = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">double</span> h)</span> </span>&#123;</span><br><span class="line">        height = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器声明。一旦我们显式地定义了一个如public TriAngle(double b, double h) &#123;&#125;类的造器之后，系统便不再提供默认的空参构造器，即Triangle t1 = new Triangle();就没有用了，必须要再定义一个空的构造器public Triangle()&#123;&#125;才能使用Triangle t1 = new Triangle();创建对象t1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TriAngle</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TriAngle</span><span class="params">(<span class="keyword">double</span> b, <span class="keyword">double</span> h)</span> </span>&#123;</span><br><span class="line">        base = b;</span><br><span class="line">        height = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    声明计算面积的公共的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> area = base * height / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-6-JavaBean（后面再提）"><a href="#4-6-JavaBean（后面再提）" class="headerlink" title="4.6 JavaBean（后面再提）"></a>4.6 JavaBean（后面再提）</h2><p>所谓JavaBean，其实是一种符合如下标准的Java类：</p>
<blockquote>
<p>类是公共的；</p>
<p>有一个无参的公共的构造器；</p>
<p>有属性，且有对应的get、set方法。</p>
</blockquote>
<h2 id="4-7-关键字this"><a href="#4-7-关键字this" class="headerlink" title="4.7 关键字this"></a>4.7 关键字<code>this</code></h2><p><code>this</code>可以用来调用属性、方法、构造器，可以将理解为对当前对象的引用。</p>
<h3 id="4-7-1-this调用属性和方法"><a href="#4-7-1-this调用属性和方法" class="headerlink" title="4.7.1 this调用属性和方法"></a>4.7.1 <code>this</code>调用属性和方法</h3><p>在类的方法中，this就代表当前对象，我们可以使用<code>this.属性</code>或者<code>this.方法</code>的方式，调用当前对象属性或者方法。但是通常情况下，我们都选择省略<code>this</code>。特殊地，如果方法的形参和类的属性同名时，我们必须显式地使用<code>this.变量</code>的方式，表明此变量是属性，而非形参。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">    	<span class="comment">//如果这里不是用this修饰，那么便会默认是形参自己给自己赋值</span></span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-7-2-this调用构造器"><a href="#4-7-2-this调用构造器" class="headerlink" title="4.7.2 this调用构造器"></a>4.7.2 <code>this</code>调用构造器</h3><p>1.在类的构造器中，可以显式地使用<code>this(形参列表)</code>方式，调用本类重载的<strong>其他</strong>构造器；<br>2.构造器中不能通过<code>this(形参列表)</code>调用自己；<br>3.规定：<code>this(形参列表)</code>必须声明在当前构造器的首行；<br>4.由于<code>this(形参列表)</code>只能位于首行，多写那就不是在首行了，所以最多只能声明一个<code>this(形参列表)</code>，用来调用其他的构造器；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">constuctor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.eat();</span><br><span class="line">    <span class="keyword">this</span>.sleep();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">constructor</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();<span class="comment">//调用上面一个空参的构造器constructor()&#123;&#125;，执行了其中调用eat方法后再调用sleep方法的步骤</span></span><br><span class="line">    <span class="keyword">this</span>.walk();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">constructor</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(x);<span class="comment">//调用上面那个构造器constructor(double x)&#123;&#125;，执行了其中调用空参构造器，并且调用walk方法的步骤</span></span><br><span class="line">    <span class="comment">//this(x,y);是错的，构造器不能调用自己</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">/*this();</span></span><br><span class="line"><span class="comment">    this(x);*/</span></span><br><span class="line">    <span class="comment">//这样写也是错的，因为只能声明一个this(形参列表)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-8-package、import关键字"><a href="#4-8-package、import关键字" class="headerlink" title="4.8 package、import关键字"></a>4.8 <code>package</code>、<code>import</code>关键字</h2><h3 id="4-8-1-package关键字"><a href="#4-8-1-package关键字" class="headerlink" title="4.8.1 package关键字"></a>4.8.1 <code>package</code>关键字</h3><p>为了解决项目（project）中有众多复杂的类和接口的问题，使用包来进行管理，类似文件夹管理文件。使用<code>package</code>在首行声明类或者接口所属的包。一般使用小写字母命名<code>xxyyzz</code>，每<code>.</code>一次就代表一层文件目录。比如<code>xx.yy.zz</code>就说明xx是yy的父目录，yy是zz的父目录。且同一个包下不能有同名的类或接口。JDK中常用的包如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>包名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>java.lang</code></td>
<td>包含一些java语言的核心类，如 <code>String</code>、<code>Math</code>、<code>Integer</code>、<code>System</code>、<code>Thread</code>等，提供常用功能</td>
</tr>
<tr>
<td><code>java.net</code></td>
<td>包含执行与网络相关的操作的类和接口</td>
</tr>
<tr>
<td><code>java.io</code></td>
<td>包含能提供多种输入/输出功能的类</td>
</tr>
<tr>
<td><code>java.util</code></td>
<td>包含了一些实用的工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的方法</td>
</tr>
<tr>
<td><code>java.text</code></td>
<td>包含了一些java格式化相关的类</td>
</tr>
<tr>
<td><code>java.sql</code></td>
<td>包含了java进行JDBC数据库编程的相关类/接口</td>
</tr>
<tr>
<td><code>java.awt</code></td>
<td>包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类用来构建和管理应用程序的图形用户界面（GUI）B/S、C/S由于做出的界面极其丑陋，所以一般不用这个做GUI。现在一般是通过浏览器来访问后台服务器</td>
</tr>
</tbody>
</table>
</div>
<h3 id="4-8-2-import关键字"><a href="#4-8-2-import关键字" class="headerlink" title="4.8.2 import关键字"></a>4.8.2 <code>import</code>关键字</h3><p>使用<code>import</code>结构导入指定包下的类、接口声明在包声明和类声明之间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;<span class="comment">//导入util包下的Scanner类</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;<span class="comment">//导入util包下的Arrays类</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;<span class="comment">//导入util包下的所有的类和接口，不包括其子包的类和接口，子包需要额外导入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意，源文件都是默认导入了lang包中的所有类和接口，不用再导包</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;<span class="comment">//lang包中的子包reflect包下的Filed类不是lang包下的类，而是其子包reflect下的，所以一定要显式导包，不能省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果源文件中使用的类或接口是本包下定义的，则可以不用导包，直接调用即可</span></span><br><span class="line"><span class="comment">//尽管不同的包下的类或接口可以同名，但是若是想同时用这些同名的类或接口，则必须在使用前加上完整的包名（这样的类名称作全类名），如：</span></span><br><span class="line">pers.zhangsan.exercises.Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">pers.lisi.exercises.Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">//拓展：import static可以导入类或接口中的静态结构（属性或方法），了解即可</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;<span class="comment">//切忌这样写：import static java.lang.Math;</span></span><br><span class="line">out.println(<span class="string">&quot;好好学习，天台向上&quot;</span>);</span><br><span class="line"><span class="keyword">long</span> num = round(<span class="number">123.456</span>);</span><br></pre></td></tr></table></figure>
<h1 id="5-面向对象编程（中）"><a href="#5-面向对象编程（中）" class="headerlink" title="5. 面向对象编程（中）"></a>5. 面向对象编程（中）</h1><h2 id="5-1-继承性inheritance（面型对象特征之二）"><a href="#5-1-继承性inheritance（面型对象特征之二）" class="headerlink" title="5.1 继承性inheritance（面型对象特征之二）"></a>5.1 继承性<code>inheritance</code>（面型对象特征之二）</h2><h3 id="5-1-1-继承的格式"><a href="#5-1-1-继承的格式" class="headerlink" title="5.1.1 继承的格式"></a>5.1.1 继承的格式</h3><p><code>class A extends B&#123;&#125;</code>，其中，A称作<font color="red">子类或者派生类</font><code>subclass</code>，B称作<font color="red">父类或者基类或者派生类</font><code>superclass</code>。一旦子类A继承父类B以后，子类中就继承了父类B中声明的所有属性和方法。特别的，父类中如果声明了<code>private</code>的属性和方法，仍然能被继承，只不过因为封装性的影响使得不能直接调用父类中的属性和方法而已。子类继承父类之后，还可以声明自己特有的属性和方法，实现功能的拓展。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inheritance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SubClass subClassTest = <span class="keyword">new</span> SubClass();</span><br><span class="line"></span><br><span class="line">        System.out.println(subClassTest.a + <span class="string">&quot;\t&quot;</span> + subClassTest.b + <span class="string">&quot;\t&quot;</span> + subClassTest.c);</span><br><span class="line"></span><br><span class="line">        subClassTest.eat();</span><br><span class="line">        subClassTest.sleep();</span><br><span class="line">        subClassTest.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学习&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：<br><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210301153344790.png" alt="image-20210301153344790"></p>
<h3 id="5-1-2-Java中关于继承的规定"><a href="#5-1-2-Java中关于继承的规定" class="headerlink" title="5.1.2 Java中关于继承的规定"></a>5.1.2 Java中关于继承的规定</h3><p>1.一个类可以被多个子类继承，<strong>但是一个类只能有一个父类（Java的单继承性）</strong>；<br>2.子、父类是相对的概念；<br>3.子类直接继承的父类，称为直接父类，间接继承的父类称为间接父类；<br>4.子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法；<img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210301161803501.png" alt="image-20210301161803501"></p>
<font color="red">5.`Object`类是类层次结构的根，每个类都有`Object`作为父类，所有对象（包括数组）都实现此类的方法。</font>

<h2 id="5-2-方法的重写override-overwrite"><a href="#5-2-方法的重写override-overwrite" class="headerlink" title="5.2 方法的重写override/overwrite"></a>5.2 方法的重写<code>override</code>/<code>overwrite</code></h2><blockquote>
<p>在子类中对从父类中继承而来的方法进行改造，也称作方法 的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。</p>
</blockquote>
<p>重写规则如下：</p>
<p>1.子类重写方法必须与父类被重写的方法具有<strong>相同的方法名和参数列表</strong>；</p>
<p>2.子类重写方法的返回值类型<strong>不能大于父类</strong>被重写的方法的<strong>返回值类型</strong>；</p>
<blockquote>
<p>①父类中的被重写的方法的返回值是void类型，那么子类中重写的方法只能是void；②父类中被重写方法的返回值是A类型，则子类中重写方法的返回值可以是A类型或者A的子类；③父类中被重写方法的返回值是基本数据类型，则子类中重写方法的返回值必须与之相同。如：父类中的是double，则子类中也必须是double；父类中是int，则子类中必须是int。</p>
</blockquote>
<p>3.子类重写方法使用的权限修饰符<strong>不能小于父类</strong>被重写方法的<strong>访问权限</strong>；</p>
<blockquote>
<p>如：若父类中是protecte修饰的方法，则子类中重写方法必须是protected或者public；若父类中是public修饰，则子类中则只能是public。特别地，子类中不能重写父类中使用private修饰的方法。</p>
</blockquote>
<p>4.子类重写方法抛出的异常<strong>不能大于父类</strong>被重写方法的<strong>异常</strong>（到异常处理处再说明）</p>
<p>5.子类与父类中同名同参数的方法必须同时声明为非static的（即为重写），或者同时声明为static的（不是重写）</p>
<p><strong>一般来说，在实际写代码的过程中，重写方法时主要考虑的应该是设计方法体，懒得去顾及上述4条规则了，一般都照抄父类的权限修饰符、返回值类型、静态修饰符等，这里仅仅是为了介绍。</strong></p>
<p><strong>构造器和方法都能重载，但是只有方法能重写，构造器不能重写。</strong></p>
<div id="5.3"></div>

<h2 id="5-3-四种访问权限修饰符"><a href="#5-3-四种访问权限修饰符" class="headerlink" title="5.3 四种访问权限修饰符"></a>5.3 四种访问权限修饰符</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">类内部</th>
<th style="text-align:center">同一个包的不同类</th>
<th style="text-align:center">不同包的子类</th>
<th>同一个工程（含多个包）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>private</code></td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
<td>no</td>
</tr>
<tr>
<td style="text-align:center">缺省（就是不写）</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td>no</td>
</tr>
<tr>
<td style="text-align:center"><code>protected</code></td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td>no</td>
</tr>
<tr>
<td style="text-align:center"><code>public</code></td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td>yes</td>
</tr>
</tbody>
</table>
</div>
<p>1.同一个包中的其他类，如A包中的A2类不能调用A1类中<code>private</code>修饰的属性和方法，只能调用缺省、<code>protected</code>、<code>public</code>修饰的；<br>2.不同包的子类，如B包中的B1类继承于A包中的A1类，则B1类不能调用A1类中<code>private</code>和缺省修饰的属性和方法，只能调用<code>protected</code>和<code>public</code>修饰的，<code>protected</code>就是为了在不同包中只能对子类可视并调用而设计的；<br>3.不同包的普通类（非子类），如B包中的所有类不能调用A包所有类中<code>private</code>、缺省、<code>protected</code>修饰的属性和方法，只能调用<code>public</code>修饰的。</p>
<h2 id="5-4-关键字super"><a href="#5-4-关键字super" class="headerlink" title="5.4 关键字super"></a>5.4 关键字<code>super</code></h2><blockquote>
<p><code>super</code>关键字可理解为父类的…，<strong>在子类的方法或构造器中</strong>用来调用父类的属性、方法和构造器。</p>
<font color="red">注意：直接父类和间接父类都是父类。</font>

</blockquote>
<h3 id="5-4-1-super调用父类中的同名属性"><a href="#5-4-1-super调用父类中的同名属性" class="headerlink" title="5.4.1 super调用父类中的同名属性"></a>5.4.1 <code>super</code>调用父类中的同名属性</h3><p>子类中可以有父类同名的属性（数据类型可以相同，也可以不同），并不会像重写方法那样重写属性。如果在子类中调用该同名的属性的话，如果前面不写，则编译器默认在该属性前面添加了this关键字，所以都是默认调用子类的同名属性（不管是不是同数据类型，都是默认调子类的）。若想在子类的方法或者构造器中调用父类的该同名属性，由于创建对象调用过于麻烦，可以使用<code>super</code>关键字通过<code>super.同名属性</code>调用父类中的属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    String id = <span class="string">&quot;SuperClass&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    String id = <span class="string">&quot;SubClass&quot;</span>;</span><br><span class="line">    <span class="comment">//int id = 1;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(id);<span class="comment">//默认是调用子类的同名属性</span></span><br><span class="line">        System.out.println(<span class="keyword">super</span>.id);<span class="comment">//调用父类中的同名属性</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inheritance</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SuperClass superClassTest = <span class="keyword">new</span> SuperClass();</span><br><span class="line">        SubClass subClassTest = <span class="keyword">new</span> SubClass();</span><br><span class="line"></span><br><span class="line">        System.out.println(superClassTest.id);</span><br><span class="line">        System.out.println(subClassTest.id);</span><br><span class="line"></span><br><span class="line">        subClassTest.show();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>尽管子父类中出现同名属性是可以区分的，但是这样写耗费时间而且毫无意义，所以本节出现的子父类同名的情况仅仅是为了介绍。实际中，在子父类中一般不会定义同名的属性给自己找麻烦。</strong></p>
<h3 id="5-4-2-super调用父类中的被重写方法"><a href="#5-4-2-super调用父类中的被重写方法" class="headerlink" title="5.4.2 super调用父类中的被重写方法"></a>5.4.2 <code>super</code>调用父类中的被重写方法</h3><p>调用父类中的同名方法与调用同名属性大致相同。由于在子类中写同名方法其实是在子类中对父类的方法进行了覆盖、重写。编译器默认会加上<code>this</code>关键字，所以是调用子类中的方法。若想在子类的方法或者构造器中调用父类中的被重写方法，则也需要使用<code>super.方法</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来自父类的show方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//在子类SubClass中重写show方法，@Override表明这是一个重写的方法，仅起到一个解释的作用，可以删掉</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来自子类重写的show方法&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.show();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//其他的非重写方法调用父类中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来自子类中的一个非重写的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inheritance</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SubClass subClassTest = <span class="keyword">new</span> SubClass();</span><br><span class="line">        subClassTest.show();</span><br><span class="line">        subClassTest.show1();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-3-调用父类中的构造器"><a href="#5-4-3-调用父类中的构造器" class="headerlink" title="5.4.3 调用父类中的构造器"></a>5.4.3 调用父类中的构造器</h3><p>1.可以在子类构造器中显式地使用<code>super(形参列表)</code>的方式，调用父类中声明的指定的构造器，与<code>this(形参列表)</code>调用构造器一样，<code>super(形参列表)</code>必须声明在子类构造器的首行；<br>2.在构造器的首行，没有显式地声明<code>this(形参列表)</code>或<code>super(形参列表)</code>，则默认<code>super()</code>调用<strong>父类中空参的构造器</strong>；<br>3.在类的构造器中，由于<code>this(形参列表)</code>和<code>super(形参列表)</code>只能位于首行的特点，使得只能写一个。针对<code>this(形参列表)</code>或<code>super(形参列表)</code>只能二选一，不能同时出现；<br>4.在类的多个构造器中，至少有一个类的构造器使用了<code>super(形参列表)</code>调用父类中的构造器（没写的话默认是<code>super()</code>调用空参构造器）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person1</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span> <span class="keyword">extends</span> <span class="title">Person1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//此处没写则默认调用父类中的空参构造器，如果写了就调用写了的构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*public Person2()&#123;</span></span><br><span class="line"><span class="comment">        super();//写上也行，不写就默认加上了super();</span></span><br><span class="line"><span class="comment">      	//再多写一行super(age)或者this(age)就会报错，因为this(形参列表)和super(形参列表)只能位于首行的特点使得只能写一个</span></span><br><span class="line"><span class="comment">        //注意：前一个构造器与本构造器本质上是同一个构造器，所以不能同时写出，否则会报错</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*public Person2()&#123;</span></span><br><span class="line"><span class="comment">        super(age);//这样写也是错的，本构造器与调用父类中的带参构造器不是同一个类型（形参列表不同），super调用构造器只能是同一个类型的</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person2</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">         <span class="keyword">super</span>(age);<span class="comment">//调用带参的构造器</span></span><br><span class="line">        <span class="comment">//同理，这里没写就默认首先调用空参的构造器，然后再执行下一行语句</span></span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若是将上面父类中的空参构造器删了，只保留带参的那个，那么上面没写super(形参列表)和this(形参列表)的子类构造器便无法默认找到父类中的空参构造器，便会报错。因为一旦只写了带参的构造器，便不再默认提供空参的构造器了，必须手动地写一个空参的构造器。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实，this和super调用构造器有很多的相似之处，只不过前者是调用当前对象的构造器，而另一个是调用父类的构造器。<strong>由于构造器只能在构造其内部被调用，所以两者都是在构造器内部调用构造器的，其他地方都是禁止的。</strong></p>
<h2 id="5-5-子类对象实例化过程"><a href="#5-5-子类对象实例化过程" class="headerlink" title="5.5 子类对象实例化过程"></a>5.5 子类对象实例化过程</h2><p>1.从结果上来看：子类继承父类之后，就获取了父类中声明的属性或方法。创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。<br>2.从过程上来看：当我们通过子类的构造器创建子类的对象时，一定会直接或者间接地调用父类地构造器，进而调用父类的父类的构造器，直到调用到了<code>java.lang.Object</code>中空参的构造器为止，正因为加载过所有的父类的结构，所以才能看到内存中有父类中的结构（属性和方法），子类对象才可以考虑进行调用其结构。</p>
<p>需要明确的是：虽然创建子类对象时，调用了父类的构造器，但是自始至终都只创建过一个对象（即new的子类对象）</p>
<p>思考：1.为什么super(…)或this(…)调用语句不能同时在一个构造器中出现？<br>答：因为super和this调用构造器都必须声明在首行，如果同时出现多个super(…)或者同时出现多个this(…)或者同时出现super(…)和this(…)，就不是在首行了。<br>2.为什么super(…)或this(…)调用语句只能作为构造器中的第1句出现（或者说写在第一行）?<br>答：无论通过哪个构造器创建子类对象，都需要先初始化父类。目的就是在当子类继承父类之后，继承父类中所有的属性和方法，因此子类必须要知道父类如何为对象进行初始化。</p>
<h2 id="5-6-多态性Polymorphism（面型对象特征之三）"><a href="#5-6-多态性Polymorphism（面型对象特征之三）" class="headerlink" title="5.6 多态性Polymorphism（面型对象特征之三）"></a>5.6 多态性<code>Polymorphism</code>（面型对象特征之三）</h2><blockquote>
<p>多态性可以理解为一个事物的多种形态。</p>
</blockquote>
<p>1.何为多态性：<strong>多态性</strong>也一般叫做<strong>对象的多态性</strong>，简单概括起来，就是父类的引用指向子类的对象（或子类的对象赋给父类的引用）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假定此时，Man类和Woman类都继承于Person类，那么：</span></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person();<span class="comment">//创建对象</span></span><br><span class="line">Person p2 = <span class="keyword">new</span> Man();<span class="comment">//多态</span></span><br><span class="line">Person p3 = <span class="keyword">new</span> Woman();<span class="comment">//多态</span></span><br><span class="line"><span class="comment">//类似于private修饰的属性被子类继承，上述多态中的p2对象是具有子类Man中的那些特有的属性和方法的，只不过调用不了而已，由于Person类型的限制，使得只能调用子类与Person类中同名的属性以及重写的方法。p3对象也是同理</span></span><br></pre></td></tr></table></figure>
<p>2.多态的使用：虚拟方法调用。即我们在编译期，只能调用父类中声明的方法，但是在运行期，我们实际上执行的是子类中重写父类的方法。总结起来就是：编译看左边，运行看右边。3.多态性的使用前提：①类的继承关系；②方法的重写4.对象的多态性只适用于方法，不适用于属性（属性编译运行都看左边即<code>Person p1</code>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnimalTest test = <span class="keyword">new</span> AnimalTest();</span><br><span class="line">        test.func(<span class="keyword">new</span> Dog());</span><br><span class="line"></span><br><span class="line">        test.func(<span class="keyword">new</span> Cat());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*如果没有多态性的话，那么如果想分别使用Dog和Cat的eat方法和shout方法，就必须重写方法，如果有多个动物，那么就要重写多次。</span></span><br><span class="line"><span class="comment">    这样一来，太过于繁琐，写了太多重复冗余的无用代码</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Animal animal)</span></span>&#123;</span><br><span class="line">        animal.eat();</span><br><span class="line">        animal.shout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Dog dog)</span></span>&#123;</span><br><span class="line">        dog.eat();</span><br><span class="line">        dog.shout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Cat cat)</span></span>&#123;</span><br><span class="line">        cat.eat();</span><br><span class="line">        cat.shout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物，进食&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物，叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;汪！汪！汪！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;喵！喵！喵！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<br><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210303153430926.png" alt="image-20210303153430926"></p>
<p><strong>向下转型：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假定此时，Man类和Woman类都继承于Person类</span></span><br><span class="line">Person p2 = <span class="keyword">new</span> Man();</span><br><span class="line">Person p3 = <span class="keyword">new</span> Woman();</span><br><span class="line"><span class="comment">//类似于private修饰的属性被子类继承，上述多态中的p2对象是具有子类Man中的那些特有的属性和方法的，只不过调用不了而已，由于Person类型的限制，使得只能调用子类与Person类中同名的属性以及重写的方法。p3对象也是同理</span></span><br></pre></td></tr></table></figure>
<p>上述代码中，若想使用子类Man中特殊的属性和方法，则可以使用强制类型转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Man m = (Man)p2;<span class="comment">//强制类型转换（所属类型必须有子父类的关系）</span></span><br><span class="line"><span class="comment">//转换完成后就可以调用属性和方法了</span></span><br><span class="line">m.method();</span><br></pre></td></tr></table></figure>
<p>与基本数据类型中的自动类型提升<code>int number1 = 1;double number2 = number1;</code>相似，子类创建的对象赋给父类型创建的变量即<code>Person p1 = new Man()</code>会<strong>自动</strong>将其强制转换成父类型Person，并且还具有了子类Man中的那些特有的属性和方法的，只不过调用不了而已，这种转型本质上就是多态。<br>向下转型很少用，基本上都是用向上转型（多态）。而若要像<code>double number1 = 1.0;int number2 = (int)number2;</code>，将父类型强制转换成子类型，可以像上述代码一样使用强制类型转换，但是这种直接的转换方式因为容易出错，所以一般使用<code>instanceof</code>关键字进行判断。</p>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210303172607955.png" alt="image-20210303172607955"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceofTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.编译不通过</span></span><br><span class="line"><span class="comment">//        Man m1 = new Woman();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.编译通过，运行不通过</span></span><br><span class="line"><span class="comment">//        Person p1 = new Woman();</span></span><br><span class="line"><span class="comment">//        Man m1 = (Man) p1;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.编译通过，运行时通过</span></span><br><span class="line">        Object obj = <span class="keyword">new</span> Woman();</span><br><span class="line">        Person p = (Person) obj;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  a instanceof A    判断对象a是否是类A的实例，如果是，返回true，如果不是，返回false</span></span><br><span class="line"><span class="comment">        使用情境：为了避免再向下转型中出现ClassCastException的异常，再向下转型之前，使用instanceof的判断，一旦返回true，就进行向下转型，否则就不向下转型</span></span><br><span class="line"><span class="comment">        如果：a instanceof A返回true，且a instanceof B也返回true，那么类B是类A的父类</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        Man man = <span class="keyword">new</span> Man();</span><br><span class="line">        Woman woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        <span class="keyword">if</span> (person <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Person类的对象是Person类的一个实例&quot;</span>);<span class="comment">//其他的类型同理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (man <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子类Man的对象也是父类Person类型的一个实例&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (woman <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子类Woman的对象也是父类Person类型的一个实例&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(person <span class="keyword">instanceof</span> Man || person <span class="keyword">instanceof</span> Woman)) &#123;<span class="comment">//同时为false时才会执行</span></span><br><span class="line">            System.out.println(<span class="string">&quot;父类Person的对象不是子类Man和Woman的一个实例&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        Person manInPerson = <span class="keyword">new</span> Man();</span><br><span class="line">        Person womanInPerson = <span class="keyword">new</span> Woman();</span><br><span class="line">        <span class="keyword">if</span> (manInPerson <span class="keyword">instanceof</span> Person &amp;&amp; manInPerson <span class="keyword">instanceof</span> Man) &#123;</span><br><span class="line">            Man man1 = (Man) manInPerson;</span><br><span class="line">            System.out.println(<span class="string">&quot;在多态性中，子类Man的对象manInPerson是父类Person的一个实例，也是Man的一个实例&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (womanInPerson <span class="keyword">instanceof</span> Person &amp;&amp; womanInPerson <span class="keyword">instanceof</span> Woman) &#123;</span><br><span class="line">            Woman woman1 = (Woman) womanInPerson;</span><br><span class="line">            System.out.println(<span class="string">&quot;在多态性中，子类Woman的对象womanInPerson是父类Person的一个实例，也是Woman的一个实例&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(manInPerson <span class="keyword">instanceof</span> Woman || womanInPerson <span class="keyword">instanceof</span> Man)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;在多态性中，子类对象之间不是彼此类型的实例。因为没有继承关系，所以子类之间没有任何联系&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210305122249565.png" alt="image-20210305122249565"></p>
<h2 id="5-7-Object类"><a href="#5-7-Object类" class="headerlink" title="5.7 Object类"></a>5.7 <code>Object</code>类</h2><p>Object类中没有定义属性，只定义了方法。其中，数组类似类，也都继承于 Object类。</p>
<h3 id="5-7-1-equals-方法"><a href="#5-7-1-equals-方法" class="headerlink" title="5.7.1 equals()方法"></a>5.7.1 equals()方法</h3><p>1.回顾<code>==</code>运算符的使用如果比较的是基本数据类型的变量（不能与boolean类型比），则比较的是<strong>数据值</strong>是否相同（数据类型不一定要相同，会自动类型提升）；如果比较的是引用数据类型的变量，则比较的是<strong>两个对象的地址值</strong>是否相同（即两个引用（即变量）是否指向同一个对象实例），而不是比较对象本身的属性和方法是否一样。且只能用于<strong>相同类型的对象（包括子父类的对象）</strong>之间比较，否则连编译都不会通过，</p>
<p>2.equals()方法的使用<code>public boolean equals(Object obj)</code>是一个方法，而非运算符，只能用于引用数据类型。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Equals</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person1=<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>,<span class="number">21</span>);</span><br><span class="line">        Person person2=<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>,<span class="number">21</span>);</span><br><span class="line">        String str1 = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">        System.out.println(person1 == person2);<span class="comment">//false</span></span><br><span class="line">        System.out.println(person1.equals(person2));<span class="comment">//false</span></span><br><span class="line">        System.out.println(str1.equals(str2));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看Object类中的equals()方法的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);<span class="comment">//this表示当前对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，其实Object类中的equals方法跟<code>==</code>运算符相同，都是比较对象的地址值。而String类种对equals()方法进行了重写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;<span class="comment">//this表示当前对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址值是否相同，而是比较两个对象的”实体内容“是否相同。</p>
<p>3.自定义类中重写equals()方法通常情况下，自定义的类如果使用equals()方法的话，一般是想要比较两个对象的实体内容，那么就要对Object类中的equals()方法进行重写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">        Person person = (Person) obj;</span><br><span class="line">        <span class="comment">//比较两个对象的每个属性是否否相同，是否比较全部属性由自己决定</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age == person.age &amp;&amp; <span class="keyword">this</span>.name.equals(person.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般情况下都是使用IDE的快速重写equals方法，这样重写的方法较为严谨，且省时间。是否只能用于相同类型之间的对象相比，要看equals()方法的源码。</p>
<h3 id="5-7-2-toString-方法"><a href="#5-7-2-toString-方法" class="headerlink" title="5.7.2 toString()方法"></a>5.7.2 toString()方法</h3><p>1.<strong>当输出一个对象的引用时，实际上就是调用当前对象的toString，</strong>示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">toString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        String str1 = <span class="keyword">new</span> String(<span class="string">&quot;HandsomeBoy&quot;</span>);<span class="comment">//String类中重写了toString方法</span></span><br><span class="line">        System.out.println(str1.toString());</span><br><span class="line">        System.out.println(str1);<span class="comment">//因为在输出时是会默认自动调toString()的，这里不写也没关系</span></span><br><span class="line">        System.out.println(person.toString());</span><br><span class="line">        System.out.println(person);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.Object类中同String()的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.像String、Date、File、包装类等都重写了Object类中的toString()方法，使得在调用对象的toString()时，返回”实体内容”信息；4.自定义类也可以重写toString()，当调用此方法时，返回对象的”实体内容”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Person[ age=&quot;</span> + age + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot; ]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样地，也一般用IDE生成重写的toString方法。</p>
<p>……</p>
<h2 id="5-8-JUnit单元测试（了解）"><a href="#5-8-JUnit单元测试（了解）" class="headerlink" title="5.8 JUnit单元测试（了解）"></a>5.8 JUnit单元测试（了解）</h2><p>在写代码过程中，有了IDE的提示功能，语法错误能够在写代码的过程中被发现消除。但是，有时候，设计一个方法的时候，往往不知到是否能达到预期的效果，如果专门为了测试方法而去创建变量或者创建对象，再测试之后又要将这些测试代码注释掉或者删掉（因为不去掉的话，一方面会给以后查看代码带来一定的负担；另一方面在代码之间夹杂测试代码容易造成结构混乱），在代码量大的时候，光把这些无用的测试代码注掉就够头疼的了。所以，为了提高效率，专门新建另外的测试类将测试代码与主代码分开，测试时在测试类中运行就行了，并不会影响主代码的调试运行。目前主要采用JUnit单元测试来进行方法的测试，以下是在Intellig IDEA中进行JUnit单元测试的步骤：</p>
<p>1.在工程目录下新建名为”Test“的文件夹（与src文件夹在同一目录下），并且在File -&gt; Project Structure将Mark as设置为<code>Tests</code>；</p>
<p>2.在Test文件夹中创建Java类，在此类中进行单元测试。此Java类要求的格式如下：<br>①必须是public修饰的，提供公共的无参构造器；<br>②在此类中声明需要测试的方法，方法的权限是public，没有返回值，没有形参；<br>③此单元测试方法上需要声明注解<code>@Test</code>，并在单元测试类前导入<code>import org.junit.Test</code>；</p>
<p>3.声明好单元测试方法之后，就可以在方法体内测试相关的代码；</p>
<p>4.写完代码之后，右键双击单元测试方法名，运行。说明：如果执行结果没有任何异常，绿条；如果执行出现异常，红条。</p>
<p>若想直接测试已有类中的方法，可以在需要测试的类上右键 -&gt; Go To -&gt; Test，选择 “create new test…”，打开生成界面，在生成界面中选择Testing Library为JUnit 4，同时勾选需要测试的函数，然后点击OK即可生成。</p>
<h2 id="5-9-包装类（Wrapper）"><a href="#5-9-包装类（Wrapper）" class="headerlink" title="5.9 包装类（Wrapper）"></a>5.9 包装类（Wrapper）</h2><blockquote>
<p>为了弥补基本数据类型不具有类特性的缺点，针对八种基本数据类型定义相应的引用类型——包装类（封装类），使得基本数据类型的变量具有类的特征。</p>
</blockquote>
<p>其中，前6种数值型的包装类的父类是Number（继承于Number类）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">byte</td>
<td>Byte</td>
</tr>
<tr>
<td style="text-align:left">short</td>
<td>Short</td>
</tr>
<tr>
<td style="text-align:left"><font color="red">int</font></td>
<td><font color="red">Integer</font></td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td>Long</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td>Float</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td>Double</td>
</tr>
<tr>
<td style="text-align:left">boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td style="text-align:left"><font color="red">char</font></td>
<td><font color="red">Character</font></td>
</tr>
</tbody>
</table>
</div>
<p>应掌握基本数据类型、包装类、String三者之间的相互转换，下面为基本数据类型与包装类之间的转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Difference test = <span class="keyword">new</span> Difference();</span><br><span class="line">        System.out.println(test.isBoy);<span class="comment">//false，基本数据类型默认值为0</span></span><br><span class="line">        System.out.println(test.isGirl);<span class="comment">//null，类类型默认值为null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//基本数据类型-&gt;包装类：调用包装类的构造器</span></span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">        Integer int1 = <span class="keyword">new</span> Integer(num1);</span><br><span class="line">        System.out.println(int1.toString());<span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">        Integer int2 = <span class="keyword">new</span> Integer(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        System.out.println(int2.toString());<span class="comment">//123</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//报异常，Integer的形参不管是String型还是int型，值必须是数字</span></span><br><span class="line"><span class="comment">//        Integer in3 = new Integer(&quot;123abc&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(in3.toString());</span></span><br><span class="line"></span><br><span class="line">        Float f1 = <span class="keyword">new</span> Float(<span class="number">13.0f</span>);</span><br><span class="line">        Float f2 = <span class="keyword">new</span> Float(<span class="string">&quot;13.0f&quot;</span>);</span><br><span class="line">        System.out.println(f1);</span><br><span class="line">        System.out.println(f2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//特别地，Boolean包装类的String型的形参可以忽略大小写，而boolean型形参不能</span></span><br><span class="line">        Boolean b1 = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line">        Boolean b2 = <span class="keyword">new</span> Boolean(<span class="string">&quot;TrUe&quot;</span>);</span><br><span class="line">        Boolean b3 = <span class="keyword">new</span> Boolean(<span class="string">&quot;true123&quot;</span>);</span><br><span class="line">        System.out.println(b3);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//包装类-&gt;基本数据类型：调用包装类Xxx的xxxValue()</span></span><br><span class="line">        Integer int3 = <span class="keyword">new</span> Integer(<span class="number">12</span>);</span><br><span class="line">        <span class="keyword">int</span> i1 = int3.intValue();</span><br><span class="line">        System.out.println(i1);</span><br><span class="line"></span><br><span class="line">        Float f3 = <span class="keyword">new</span> Float(<span class="number">12.3</span>);</span><br><span class="line">        <span class="keyword">float</span> f4 = f3.floatValue();</span><br><span class="line">        System.out.println(f4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Difference</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isBoy;</span><br><span class="line">    Boolean isGirl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>JDK5.0时加入了新特性：自动装箱和拆箱，以后直接使用即可。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动装箱：基本数据类型---&gt;包装类</span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">Integer int1 = num;<span class="comment">//直接将基本数据类型赋值给包装类的变量</span></span><br><span class="line"><span class="keyword">boolean</span> b1 = <span class="keyword">true</span>;</span><br><span class="line">Boolean b2 = b1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动拆箱：包装类---&gt;基本数据类型</span></span><br><span class="line">System.out.println(int1.toString());</span><br><span class="line"><span class="keyword">int</span> num2 = int1;<span class="comment">//直接将包装类型的变量赋值给基本数据类型的变量</span></span><br></pre></td></tr></table></figure>
<p>下面为基本数据类型和包装类与String类型之间的转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基本数据类型、包装类-&gt;String类型</span></span><br><span class="line">        <span class="comment">//方式1：连接运算</span></span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">12</span>;</span><br><span class="line">        String str1 = num2 + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//方法2：调用String重载的valueOf(Xxx xxx)方法（更常用）</span></span><br><span class="line">        <span class="keyword">float</span> f5 = <span class="number">12.3f</span>;</span><br><span class="line">        String str2 = String.valueOf(f5);<span class="comment">//基本数据类型转String</span></span><br><span class="line">        Double d1 = <span class="keyword">new</span> Double(<span class="number">12.4</span>);</span><br><span class="line">        String str3 = String.valueOf(d1);<span class="comment">//包装类转String</span></span><br><span class="line">        System.out.println(str1 + <span class="string">&quot;\t&quot;</span> + str2 + <span class="string">&quot;\t&quot;</span> + str3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String类型-&gt;基本数据类型、包装类：调用包装类的parseXxx(String s)方法</span></span><br><span class="line">        <span class="comment">//注意：因为没有parseCharacter()方法，所以不能String-&gt;char及其包装类</span></span><br><span class="line">        String str4 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> num3 = Integer.parseInt(str4);</span><br><span class="line">        System.out.println(num3 + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//        String str4 = &quot;123abc&quot;;</span></span><br><span class="line"><span class="comment">//        int num3 = Integer.parseInt(str4);</span></span><br><span class="line"><span class="comment">//        System.out.println(num3 + 1);//NumberFormatException异常，值必须是数字，不能有字母</span></span><br><span class="line">        String str5 = <span class="string">&quot;trUe&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> b4 = Boolean.parseBoolean(str5);</span><br><span class="line">        System.out.println(b4);</span><br><span class="line">        String str6 = <span class="string">&quot;true123&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> b5 = Boolean.parseBoolean(str6);</span><br><span class="line">        System.out.println(b5);</span><br></pre></td></tr></table></figure>
<p>练习：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Integer内部定义了IntegerCache类，IntegerCache中定义了1个Integer类型的数组cache[]</span></span><br><span class="line">        <span class="comment">//保存了-128~127范围的整数。如果使用自动装箱的方式，给Integer赋值的范围在-128~127范围内时，</span></span><br><span class="line">        <span class="comment">//可以直接使用数组中的元素，不用再去new对象调用方法赋值。目的：为了提高效率，只要在范围内就不用每次都去new</span></span><br><span class="line">        Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">        Integer j = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">        System.out.println(i == j);</span><br><span class="line"></span><br><span class="line">        Integer m = <span class="number">1</span>;</span><br><span class="line">        Integer n = <span class="number">1</span>;</span><br><span class="line">        System.out.println(m == n);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        Integer x = <span class="number">128</span>;</span><br><span class="line">        Integer y = <span class="number">128</span>;</span><br><span class="line">        System.out.println(x == y);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h1 id="6-面向对象编程（下）"><a href="#6-面向对象编程（下）" class="headerlink" title="6. 面向对象编程（下）"></a>6. 面向对象编程（下）</h1><h2 id="6-1-关键字static"><a href="#6-1-关键字static" class="headerlink" title="6.1 关键字static"></a>6.1 关键字static</h2><p>static可以用来修饰：属性、方法、代码块、内部类，不能修饰构造器。</p>
<h3 id="6-1-1-static修饰属性"><a href="#6-1-1-static修饰属性" class="headerlink" title="6.1.1 static修饰属性"></a>6.1.1 static修饰属性</h3><p>static修饰的属性称为<strong>静态属性</strong>，或者叫<strong>静态变量、类变量</strong>；非static修饰的属性为<strong>非静态属性</strong>，或者叫<strong>实例变量</strong>。<strong>实例变量：</strong>创建了多个对象，每个对象都独立地拥有一套类中的非静态属性。当修改其中的一个对象中的非静态属性时，不会引起其他对象中的属性值的修改；<strong>静态变量：</strong>创建了多个对象，所有对象共享同一个静态属性。当通过某一个对下个修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。</p>
<center><img alt="变量的分类-按照声明的位置" src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/变量的分类-按声明的位置.svg"></center>

<p>局部变量中除了形参，都是没有默认初始化的，需要显式初始化。</p>
<p>static修饰属性的说明：</p>
<p>1.静态变量随着类的加载而加载，所以可以直接通过<code>类.静态变量</code>的方式进行调用，所以静态变量也叫做类变量；</p>
<p>2.类和对象的调用权限：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"><strong>静态属性</strong></th>
<th style="text-align:center"><strong>非静态方法</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>类</strong></td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:center"><strong>对象</strong></td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
</tr>
</tbody>
</table>
</div>
<p>3.静态变量的加载早于对象的创建；<br>4.由于类只加载一次，则静态变量在内存中也会只存在一份，存在于方法区的静态域中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChineseTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Chinese c1 = <span class="keyword">new</span> Chinese();</span><br><span class="line">        c1.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        c1.age = <span class="number">20</span>;</span><br><span class="line">        c1.nation = <span class="string">&quot;CHN&quot;</span>;</span><br><span class="line">        Chinese c2 = <span class="keyword">new</span> Chinese();</span><br><span class="line">        c2.name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">        c2.age = <span class="number">30</span>;</span><br><span class="line">        System.out.println(c1.nation + <span class="string">&quot;\t&quot;</span> + c2.nation);</span><br><span class="line"></span><br><span class="line">        c2.nation = <span class="string">&quot;中国&quot;</span>;</span><br><span class="line">        System.out.println(c1.nation + <span class="string">&quot;\t&quot;</span> + c2.nation);</span><br><span class="line"></span><br><span class="line">        Chinese.nation = <span class="string">&quot;CHN中国&quot;</span>;</span><br><span class="line">        System.out.println(c1.nation + <span class="string">&quot;\t&quot;</span> + c2.nation + <span class="string">&quot;\t&quot;</span> + Chinese.nation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String nation;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<br><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210309203656746.png" alt="image-20210309203656746"></p>
<p>下面是一段代码的内存解析：<img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210309205045010.png" alt="image-20210309205045010"></p>
<h3 id="6-1-2-static修饰方法"><a href="#6-1-2-static修饰方法" class="headerlink" title="6.1.2 static修饰方法"></a>6.1.2 static修饰方法</h3><p>1.和静态属性类似，静态方法也随着类的加载而加载，所以也可以通过<code>类.静态方法</code>调用；</p>
<p>2.类和对象的调用权限：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">静态方法</th>
<th style="text-align:center">非静态方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>类</strong></td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:center"><strong>对象</strong></td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
</tr>
</tbody>
</table>
</div>
<p>3.静态方法中，只能调用静态的方法或属性，而非静态的方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性；</p>
<p>4.在静态的方法内，不能使用this、super关键字，因为它们是基于对象的，而静态方法随类加载，故早于对象的创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> String nation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中国人吃中餐&quot;</span>);</span><br><span class="line">        <span class="comment">//调用非静态结构</span></span><br><span class="line">        <span class="keyword">this</span>.info();</span><br><span class="line">        <span class="comment">//调用静态结构</span></span><br><span class="line">        walk();</span><br><span class="line">        System.out.println(<span class="string">&quot;nation:&quot;</span> + nation);<span class="comment">//类.静态属性 中可以省略类</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一个中国人！&quot;</span>);</span><br><span class="line">        <span class="comment">//不能调用非静态的属性、方法</span></span><br><span class="line"><span class="comment">//        eat();</span></span><br><span class="line"><span class="comment">//        name = &quot;Tom&quot;;</span></span><br><span class="line">        <span class="comment">//可以调用静态的结构</span></span><br><span class="line">        System.out.println(Chinese.nation);</span><br><span class="line">        walk();<span class="comment">//类.静态方法 中可以省略类</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name:&quot;</span> + name + <span class="string">&quot;, age:&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于静态属性和静态方法的调用，可以从生命周期的角度去理解。</p>
<p>用static修饰属性的场景：当属性值被多个对象所共享，不会随对象的不同而不同，类中的常量也常常声明为static；<br>用static修饰方法的场景：当方法操作的是静态属性时，通常也将方法也用static修饰；<br>此外，工具类中的方法也一般用static修饰以直接调用而不需要创建对象，比如Math、Arrays、Collections等。</p>
<h3 id="6-1-3-关于静态属性和方法的继承问题"><a href="#6-1-3-关于静态属性和方法的继承问题" class="headerlink" title="6.1.3 关于静态属性和方法的继承问题"></a>6.1.3 关于静态属性和方法的继承问题</h3><blockquote>
<p>静态方法和属性都可以被继承（因为静态的都是随类加载的，属于类的一部分）。<br>但是非静态方法属于类的实例，是可以被子类重写，从而达到多态的效果；而静态方法属于类，是不能被重写，故而也不能实现多态。</p>
</blockquote>
<p>如果子类里面定义了与父类同名的静态方法和属性，那么这时候父类的静态方法或静态属性没有被重写而是“隐藏”。重写的功能是：”重写”后子类的优先级要高于父类的优先级，但是“隐藏”是没有这个优先级之分的。若想要调用父类的静态方法和属性，直接通过<code>类.属性或方法</code>即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Students.age);<span class="comment">//子类调用父类中的静态属性</span></span><br><span class="line">        System.out.println(Students.name);<span class="comment">//子类调用自己的静态属性</span></span><br><span class="line">        Students.eat();<span class="comment">//子类调用子类中的静态方法</span></span><br><span class="line">        Students.talk();<span class="comment">//子类调用父类中的静态方法，继承</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String name = <span class="string">&quot;Person&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类Person吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类Person说话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Students</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性名相同</span></span><br><span class="line">    <span class="keyword">static</span> String name = <span class="string">&quot;Students&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类Students吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210313171812893.png" alt="image-20210313171812893"></p>
<h3 id="6-1-4-补充点：类的单例设计模式"><a href="#6-1-4-补充点：类的单例设计模式" class="headerlink" title="6.1.4 补充点：类的单例设计模式"></a>6.1.4 补充点：类的单例设计模式</h3><p>所谓类的单例设计模式，就是采取一定的方法以保证在整个软件系统中，<u>对某个类<strong>只能存在一个对象实例</strong>，并且该类只能提供一个取得其对象实例的方法。</u><br>如果要让类在一个虚拟机中只能产生一个对象，首先必须将<strong>类的构造器的访问权限设置为private</strong>，这样，就不能在类外部new出对象了，但是在类内部仍然可以产生该类的对象。由于在类外部开始还无法得到类的对象，只能<strong>调用该类的某个静态方法</strong>已返回类内部创建的对象，静态方法也只能访问类中的静态成员变量，所以，指向类内部产生的<strong>该类对象的变量也必须定义成静态的</strong>。</p>
<p>下面通过两种写法来体会类的单例设计模式：<br>1.饿汉式实现：好处是线程安全（到后面的多线程再提），坏处是对象的加载时间过长</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单例模式的饿汉式实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTonTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bank bank1 = Bank.getInstance();</span><br><span class="line">        Bank bank2 = Bank.getInstance();</span><br><span class="line">        System.out.println(bank1 == bank2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.私有化类的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.内部创建类的对象，对象也必须声明成static以被静态的方法调用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bank instance = <span class="keyword">new</span> Bank();<span class="comment">//先造好对象，饿</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供公共的方法，返回类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.懒汉式实现：好处是延迟对象的创建，坏处下面的写法线程不安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单例模式的懒汉式实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTonTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Order order1 = Order.getInstance();</span><br><span class="line">        Order order2 = Order.getInstance();</span><br><span class="line">        System.out.println(order1 == order2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.私有化类的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Order</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.声明当前对象，但是没有初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Order instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.声明public、static的返回当前类对象的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Order();<span class="comment">//用的时候再造对象，懒</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-2-理解main方法的语法"><a href="#6-2-理解main方法的语法" class="headerlink" title="6.2 理解main方法的语法"></a>6.2 理解main方法的语法</h2><p>main方法作为程序的入口，其实也只是一个普通的静态方法。每个类中都可以创建main方法，只不过在运行时需要选择进入的是哪个类的main方法。</p>
<h2 id="6-3-类的成员之四：代码块（很少用）"><a href="#6-3-类的成员之四：代码块（很少用）" class="headerlink" title="6.3 类的成员之四：代码块（很少用）"></a>6.3 类的成员之四：代码块（很少用）</h2><p><code>&#123;...&#125;</code>用来初始化类、对象，如果要修饰的话，只能用static修饰。按是否修饰分为静态代码块、非静态代码块。在类的内部可以定义多个静态代码块，按声明的顺序执行。但是一般不会写多个代码块，都写在一个代码块里面。作用：初始化类或对象的信息。由于静态是随类加载的，早于对象的创建，所以不管声明顺序如何，静态与非静态之间一定是先执行静态，后执行非静态的。</p>
<p>静态代码块：内部可以有输出语句，随着类的加载而执行，由于类只加载一次，所以也只执行一次。只能调用静态的属性、方法，不能调用非静态的结构。</p>
<p>非静态代码块：内部可以有输出语句，随着对象的创建而执行，并且每创建一个对象就执行一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello, static block-1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello, static block-2&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由父及子，静态先行</p>
<h2 id="6-4-关键字final"><a href="#6-4-关键字final" class="headerlink" title="6.4 关键字final"></a>6.4 关键字final</h2><p>final可以用来修饰类、方法、变量。</p>
<h3 id="6-4-1-final修饰类"><a href="#6-4-1-final修饰类" class="headerlink" title="6.4.1 final修饰类"></a>6.4.1 final修饰类</h3><p>final修饰类表明不能被其他类继承。比如：String类、System类、StringBuffer类。</p>
<h3 id="6-4-2-final修饰方法"><a href="#6-4-2-final修饰方法" class="headerlink" title="6.4.2 final修饰方法"></a>6.4.2 final修饰方法</h3><p>final修饰方法表明此方法不能被重写。比如：Object类的getClass()</p>
<h3 id="6-4-3-final修饰变量"><a href="#6-4-3-final修饰变量" class="headerlink" title="6.4.3 final修饰变量"></a>6.4.3 final修饰变量</h3><p>final修饰变量之后，此时的变量就称为常量，<strong>不能再改</strong>。</p>
<p>1.final修饰属性，可以考虑的赋值位置有：显式初始化、代码块中初始化、构造器中初始化；<br>2.final修饰局部变量，尤其是使用final修饰形参时，表明此形参是一个常量，当调用此方法时，给常量形参赋一个实参，<strong>一旦赋值以后，就只能在方法体内使用此形参（因为局部变量只能在方法体内被使用），即只能用，不能改。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Something</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Other o = <span class="keyword">new</span> Other();</span><br><span class="line">        <span class="keyword">new</span> Something().addOne(o);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">(<span class="keyword">final</span> Other o)</span></span>&#123;</span><br><span class="line">        o.i++;<span class="comment">//编译通过，因为只是o不能改，但是其成员并没有用final修饰，是可以修改的        </span></span><br><span class="line">        <span class="comment">//o = new Other();//编译不通过，o不能改</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>static final</code>只能用来修饰属性和方法，修饰属性时该属性是全局常量，表明只能被初始化，不能再改，且所有的对象都共用该属性。</p>
<h2 id="6-5-抽象类与抽象方法（使用关键字abstract）"><a href="#6-5-抽象类与抽象方法（使用关键字abstract）" class="headerlink" title="6.5 抽象类与抽象方法（使用关键字abstract）"></a>6.5 抽象类与抽象方法（使用关键字abstract）</h2><h3 id="6-5-1-抽象类"><a href="#6-5-1-抽象类" class="headerlink" title="6.5.1 抽象类"></a>6.5.1 抽象类</h3><center><img alt="人的分类" src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/人.svg"></center>

<blockquote>
<p>可以看到，人是父类，有多个子类。但是随着人不断地被子类继承，人越来越抽象化，而其子类越来越具体化。那么在创建对象的时候慢慢地就不再使用父类了，父类仅仅起一个基类的作用，设置一些基本的属性和方法去给子类继承。此时就用关键字abstract修饰该类，使得其不可实例化（创建对象），而使用子类去new对象。</p>
</blockquote>
<p>尽管抽象类不能new对象，但是内部一定会有构造器，因为子类在创建对象（实例化）的过程中一定会调用父类的构造器。<strong>所以抽象类都是有子类继承的，否则抽象类就毫无意义。</strong></p>
<h3 id="6-5-2-抽象方法"><a href="#6-5-2-抽象方法" class="headerlink" title="6.5.2 抽象方法"></a>6.5.2 抽象方法</h3><p>同样地，abstract也可以修饰方法，如：<code>public abstract void eat();</code>，该方法是没有方法体的。</p>
<p>1.”类包含抽象方法“是“类是抽象类（即必须声明为abstract）”的充分不必要条件；</p>
<p>2.只有子类重写了父类（<strong>时刻记住：父类包含直接父类和间接父类</strong>）中的所有抽象方法后，方可实例化。如果子类不重写父类中的抽象方法，那么表明该类是一个抽象类，需要使用abstract修饰；</p>
<p>3.abstract不能用来修饰私有方法（私有的方法不能被子类访问，而abstract方法又一定要被子类重写）、静态方法（因为静态方法不能被重写，或者说那不叫重写，是“隐藏”）、final方法（final方法不能重写）、final类（final类不能被继承）。</p>
<h3 id="6-5-3-抽象性的使用场景"><a href="#6-5-3-抽象性的使用场景" class="headerlink" title="6.5.3 抽象性的使用场景"></a>6.5.3 抽象性的使用场景</h3><p>举个例子：<br>父类人会吃饭，但是吃饭的子类人群不同，如子类Worker和Student。多吃饭的原因也不同，如工人干重活辛苦要多吃饭，学生在长身体要多吃饭。那么当我们想要按照不同的人群去定义多吃饭的原因的话，可以在子类中分别写不同的方法。<br>然而，以后可能要写的方法可能不止吃饭的原因这一个，可能还有睡觉、洗脸等。方法一多，可能在子类中写着写着就可能会漏掉一些。此时如果在父类中定义了抽象方法，那么如果在子类中忘了重写某个继承自父类的抽象方法，便会报错提醒，这样一来就不会漏掉了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Workers worker = <span class="keyword">new</span> Workers();</span><br><span class="line">        Students students = <span class="keyword">new</span> Students();</span><br><span class="line">        worker.eat();</span><br><span class="line">        students.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Workers</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;工人干很多重活，要多吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Students</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生正是长身体的时候，要多吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-5-4-创建抽象类的匿名子类对象"><a href="#6-5-4-创建抽象类的匿名子类对象" class="headerlink" title="6.5.4 创建抽象类的匿名子类对象"></a>6.5.4 创建抽象类的匿名子类对象</h3><p>类似匿名对象，也可创建匿名的子类，使用一次就丢掉。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person()&#123;<span class="comment">//没有创建类，而是利用多态性直接创建了一个匿名的子类（因为抽象类Person是不能实例化的），在匿名子类中重写方法，省去了专门写子类的步骤（归来起来，就是懒）</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这是一个只会吃饭的匿名子类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210312095441195.png" alt="image-20210312095441195"></p>
<h2 id="6-6-接口（interface）"><a href="#6-6-接口（interface）" class="headerlink" title="6.6 接口（interface）"></a>6.6 接口（interface）</h2><blockquote>
<p>接口就是规范，定义的是一组规则，体现了现实世界中<strong>如果你是/要…则必须能…</strong>的思想。继承是一个<strong>是或不是</strong>的关系，而接口实现则是<strong>能不能</strong>的关系。本质上，接口就是契约、标准、规范，就像法律一样，制定好后大家都要遵守。</p>
</blockquote>
<p>1.接口使用interface定义，是与类是并列的结构；<br>2.<strong>接口中不能定义构造器！</strong>因此接口不可以实例化，一般通过类去<strong>实现（implements）</strong>的方式来使用。<strong>如果实现类覆盖了接口中<font color="red">所有的抽象方法</font>，则此实现类可以实例化；</strong>若没有，则此实现类仍为一个抽象类，需要用abstract修饰；<br>3.Java类可以实现多个接口，弥补了java单继承性的局限性。格式<code>class AA extends BB implements CC,DD,EE</code>；<br>4.接口与接口之间可以继承，所以也满足多态性，而且还可以多继承。</p>
<p>以下是JDK7及以前的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JDK7及以前，只能定义全局常量和抽象方法</span></span><br><span class="line"><span class="comment">//全局常量：public static final的方法，但是书写时可以省略不写</span></span><br><span class="line"><span class="comment">//抽象方法：public abstract的方法，书写时也可省略不写</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(Flyable.MAX_SPEED);</span><br><span class="line">        System.out.println(Flyable.MIN_SPEED);</span><br><span class="line">        <span class="comment">//Flyable.MIN_SPEED = 2;//报错，常量不可赋值</span></span><br><span class="line">        Plane plane = <span class="keyword">new</span> Plane();</span><br><span class="line">        plane.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SPEED = <span class="number">7000</span>;<span class="comment">//没有省略</span></span><br><span class="line">    <span class="keyword">int</span> MIN_SPEED = <span class="number">1</span>;<span class="comment">//省略了public static final</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;<span class="comment">//省略了public abstract</span></span><br><span class="line">    <span class="comment">//所以不管接口中变量声明是否加了修饰符，一定都是public static final修饰的，都是“不能修改的静态常量”</span></span><br><span class="line">    <span class="comment">//抽象方法也是同样的道理，一定都用public abstract修饰的，都是抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Attackable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plane</span> <span class="keyword">implements</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;通过引擎起飞&quot;</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;驾驶员减速停止&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Kite</span> <span class="keyword">implements</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果没有全部覆盖接口中的方法，那么类必须声明成abstract</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bullet</span> <span class="keyword">implements</span> <span class="title">Flyable</span>,<span class="title">Attackable</span></span>&#123;<span class="comment">//继承多个接口</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210312233113331.png" alt="image-20210312233113331"></p>
<p>JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法；（JDK7及以前的写法用得比较多）<br>1.接口中定义的静态方法，只能被该接口调用；<br>2.接口中定义的默认方法，只能被该接口的实现类的对象调用，并且可以被实现类重写<strong>（一般不重写，直接用即可，这里仅仅是为了介绍）</strong>；</p>
<p><strong>注意：真正写代码的时候，一般也不会定义同名同参数的方法给自己找麻烦，以下的重名情况仅仅是为了介绍。</strong><br>3.如果子类（或实现类）继承的父类和实现的接口中声明了同名同参数的方法，则子类在没有重写此方法的前提下，默认调用的是父类中的父类中的同名同参数方法。—-&gt;<strong>类优先原则（针对方法）</strong>；<br>4.如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，那么在实现类没有重写此方法的情况下，就会报错—-&gt;即接口冲突。若想实现该方法，则必须在实现类中重写此方法；</p>
<p>5.若实现类对接口中的默认方法进行了重写（静态方法不能被重写），那么就像子类调用父类中被重写的方法一样，如果想调用接口中被重写的方法，则使用<code>接口名.super.方法</code>调用。</p>
<p>以下是JDK8的新特性（使得接口越来越像类了）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JDK8</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interface2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SubClass s = <span class="keyword">new</span> SubClass();</span><br><span class="line">        <span class="comment">//s.method1();//报错</span></span><br><span class="line">        <span class="comment">//SubClass.method1();//报错</span></span><br><span class="line">        <span class="comment">//1.接口调用自己的静态方法</span></span><br><span class="line">        Interface.method1();<span class="comment">//interface：北京</span></span><br><span class="line">        <span class="comment">//Interface.method3();//报错</span></span><br><span class="line">        System.out.println(<span class="string">&quot;**************************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.对象调用默认方法</span></span><br><span class="line">        s.method2();<span class="comment">//SuperClass：上海</span></span><br><span class="line">        System.out.println(<span class="string">&quot;**************************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.类优先原则</span></span><br><span class="line">        s.method2();<span class="comment">//SuperClass：上海</span></span><br><span class="line">        System.out.println(<span class="string">&quot;**************************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.多个接口的默认方法同名问题</span></span><br><span class="line">        s.method3();<span class="comment">//SubClass：南京</span></span><br><span class="line">        System.out.println(<span class="string">&quot;**************************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.调用接口中被重写的方法</span></span><br><span class="line">        s.myMethod();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;<span class="comment">//可以定义静态方法，有方法体，默认都是public的，可以省略</span></span><br><span class="line">        System.out.println(<span class="string">&quot;interface：北京&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;<span class="comment">//定义默认方法，关键字default，默认都是public的，可以省略</span></span><br><span class="line">        System.out.println(<span class="string">&quot;interface：上海&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface：南京&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface11</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;interface11：南京&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperClass：上海&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperClass：南京&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> <span class="keyword">implements</span> <span class="title">Interface</span>,<span class="title">Interface11</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SubClass：南京&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        method3();<span class="comment">//调用重写的方法</span></span><br><span class="line">        <span class="keyword">super</span>.method3();<span class="comment">//调用父类中声明的方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用接口中的默认方法</span></span><br><span class="line">        Interface.<span class="keyword">super</span>.method3();</span><br><span class="line">        Interface11.<span class="keyword">super</span>.method3();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结关于抽象类和接口的异同点：<br>相同点：都不能被实例化、都可以被继承；<br>不同点：抽象类有构造器，而接口内部不能声明构造器；抽象类只能被单继承，接口可以被多继承</p>
<h2 id="6-7-类的成员之五：内部类（几乎不用）"><a href="#6-7-类的成员之五：内部类（几乎不用）" class="headerlink" title="6.7 类的成员之五：内部类（几乎不用）"></a>6.7 类的成员之五：内部类（几乎不用）</h2><blockquote>
<p>Java中允许将一个类A声明在类B中，则类A就是内部类，类B称为外部类。</p>
</blockquote>
<p>1.内部类分类：成员内部类、局部内部类（方法内、代码块内、构造器内）</p>
<p>2.成员内部类：<br>①一方面，作为外部类的成员：调用外部类的结构；可以被static修饰；可以被四种权限修饰符修饰；<br>②另一方面，作为一个类：类内可以定义属性、方法、构造器等；可以被final修饰，表示此类不可被继承；可以被abstract修饰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Dog实例（静态成员的内部类）</span></span><br><span class="line">        Animal.Dog dog = <span class="keyword">new</span> Animal.Dog();<span class="comment">//内部类作为结构被外部类调用再去创建对象</span></span><br><span class="line">        dog.show();<span class="comment">//内部类的对象调用方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Bird实例（非静态的成员内部类）</span></span><br><span class="line">        <span class="comment">//静态成员内部类可以被外部类直接调用从而去创建对象</span></span><br><span class="line">        <span class="comment">//而非静态的成员内部类必须先创建对象，通过对象去调用内部类从而调用对象</span></span><br><span class="line">        Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line">        Animal.Bird bird = a.<span class="function">new <span class="title">Bird</span><span class="params">()</span></span>;<span class="comment">//a.new Bird()通过对象去调内部类的构造器</span></span><br><span class="line">        bird.sing();</span><br><span class="line">        bird.display(<span class="string">&quot;小动物&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    String name = <span class="string">&quot;小动物&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态成员内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">        String name = <span class="string">&quot;小狗&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Dog吃饭&quot;</span>);</span><br><span class="line">            <span class="comment">//eat();//错误的，静态不能调非静态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非静态成员内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">        String name = <span class="string">&quot;小鸟&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是一个小小小小鸟&quot;</span>);</span><br><span class="line">            eat();<span class="comment">//调用外部类的非静态属性，默认省略了 Animal.this.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">            System.out.println(name);<span class="comment">//调用形参</span></span><br><span class="line">            System.out.println(<span class="keyword">this</span>.name);<span class="comment">//调用形参Bird内部类的属性</span></span><br><span class="line">            System.out.println(Animal.<span class="keyword">this</span>.name);<span class="comment">//调用Animal外部类的属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.局部内部类一般写在方法内部，常见写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回一个实现了Comparable接口的类的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Comparable <span class="title">getComparable</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个实现了Comparable接口的类：局部内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyComparable</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">        <span class="comment">//重写Comparable接口中的compareTo(Object o)</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyComparable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成员内部类和局部内部类在编译之后都会生成字节码文件，文件格名式如下：<br>成员内部类：<code>外部类\$内部类名.class</code><br>局部内部类：<code>外部类$数字 内部类名.class</code></p>
<h1 id="7-异常处理"><a href="#7-异常处理" class="headerlink" title="7. 异常处理"></a>7. 异常处理</h1><h2 id="7-1-异常概述与异常体系结构"><a href="#7-1-异常概述与异常体系结构" class="headerlink" title="7.1 异常概述与异常体系结构"></a>7.1 异常概述与异常体系结构</h2><p>在使用计算机语言机型项目开发的过程中，即使程序员代码写得尽善尽美，在系统的运行过程中仍然会遇到一些问题，因为很多问题不是靠代码能够避免的，比如：用户输入数据的格式，读取文件是否存在，网络是否保持通畅等等。</p>
<blockquote>
<p>在Java语言中，将程序执行中发生的不正常情况称为异常（语法错误和逻辑错误不是异常）。在执行过程中发生的异常可分为Error和Exception。</p>
</blockquote>
<p>Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverFlow和OOM。<strong>一般也不编写针对性的代码进行处理。</strong></p>
<p><strong>Exception：其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如：空指针访问、试图读取不存在的文件、网络连接中断、数组角标越界等。</strong></p>
<center><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.svg"/></center>

<p>常见的运行时异常如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>异常类型</th>
<th>异常原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>NullPointerException（空指针异常）</td>
<td>调用值为null的对象</td>
</tr>
<tr>
<td>IndexOutOfBoundException（索引越界异常）</td>
<td>超出索引范围</td>
</tr>
<tr>
<td>ClassCastException（类型转换异常）</td>
<td>类型强制转换时本质上不能转换</td>
</tr>
<tr>
<td>NumberFormatException（数字格式异常）</td>
<td>数值类型相关的转换时出现异常</td>
</tr>
<tr>
<td>InputMismatchException（输入类型不匹配异常）</td>
<td>输入类型与给定变量的类型不匹配</td>
</tr>
<tr>
<td>ArithmeticException（）</td>
<td>数学运算违规，如：除以0、负数开方等</td>
</tr>
</tbody>
</table>
</div>
<h2 id="7-2-异常处理"><a href="#7-2-异常处理" class="headerlink" title="7.2 异常处理"></a>7.2 异常处理</h2><blockquote>
<p>所谓异常处理，就是将可能出现的异常错误用一种方式给隐藏起来了，换上了较为友好的异常提示。比如：乱码、闪退等情况换成了文字提示，但是本质上并没有解决异常。<strong>要想解决异常，只能修改代码。</strong></p>
</blockquote>
<h3 id="7-2-1-异常处理：抓抛模型"><a href="#7-2-1-异常处理：抓抛模型" class="headerlink" title="7.2.1 异常处理：抓抛模型"></a>7.2.1 异常处理：抓抛模型</h3><p>过程一（抛）：程序在正常执行的过程中，一旦出现异常，就会在代码出生成一个对应异常类的对象，并将此对象抛出。一旦抛出对象之后，其后的代码就不再执行。<br>过程二（抓）：可以理解为异常的处理方式：① try-catch-finally    ② throws</p>
<h3 id="7-2-2-异常处理机制一：try-catch-finally"><a href="#7-2-2-异常处理机制一：try-catch-finally" class="headerlink" title="7.2.2 异常处理机制一：try-catch-finally"></a>7.2.2 异常处理机制一：try-catch-finally</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能出现异常的代码</span></span><br><span class="line">    <span class="comment">//可能出现异常的后面代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//处理异常的方式1</span></span><br><span class="line">    <span class="comment">//可能出现异常的后面代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">//处理异常的方式2</span></span><br><span class="line">    <span class="comment">//可能出现异常的后面代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">3</span> 变量名<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="comment">//处理异常的方式3</span></span><br><span class="line">    <span class="comment">//可能出现异常的后面代码</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//一定会出现的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.使用try将可能出现的异常代码包装起来，在执行过程中一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配；<br>2.匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的try-catch结构（在没有写finally的情况），继续执行其后的代码；<br>3.catch中的异常类型如果没有子父类关系，则声明顺序就没有关系；如果满足，则要求子类一定声明在父类上面，否则报错；<br>4.常用的处理异常的2个方法：① String getMessage()    ② void printStackTrace()<br>5.在try结构中声明的变量，在出了try结构之后，就不能再调用；<br>6.try-catch-finally结构可以相互嵌套（但一般写代码时不会去嵌套）；</p>
<p>7.finally是可选的（可写可不写）；<br>8.finally在异常处理完之后，一定会被执行。如果异常处理过程中有return语句，依然会先执行finally，然后执行return语句；如果finally内部有return语句，那么执行完finally的return语句就结束了，catch后面的return语句就不再执行；<br>9.像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动地回收的，需要自己手动地进行资源的释放。此时的资源释放，就需要声明在finally中。</p>
<p>关于代码中的编译时异常和运行时异常：<br>1.使用try-catch-finally处理编译时异常，相当于将编译时可能出现的异常，延迟到运行时出现。<br>2.由于运行时异常比较常见，所以通常就不针对运行时异常编写try-catch-finally了。针对编译时异常，一定要考虑异常的处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = Integer.parseInt(str);</span><br><span class="line">            System.out.println(<span class="string">&quot;hello----1&quot;</span>);<span class="comment">//出现异常后，后面的语句就不会再执行了</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(NullPointerException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;出现空指针异常，不要着急&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NumberFormatException e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line"><span class="comment">//            System.out.println(&quot;出现数值转换异常，不要着急&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello----2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">            System.out.println(a / b);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArithmeticException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;无敌最寂寞&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">            System.out.println(a / b);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArithmeticException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;无敌最寂寞&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">            <span class="comment">//如果在finally内部加上return语句，那么catch后面的return语句就不会执行了，方法到此结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num2 = test2();</span><br><span class="line">        <span class="keyword">int</span> num3 = test3();</span><br><span class="line">        System.out.println(num2);</span><br><span class="line">        System.out.println(num3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210314111217393.png" alt="image-20210314111217393"></p>
<h3 id="7-2-3-异常处理机制二：throws"><a href="#7-2-3-异常处理机制二：throws" class="headerlink" title="7.2.3 异常处理机制二：throws"></a>7.2.3 异常处理机制二：throws</h3><p>1.”throws+异常类型“声明在方法的声明处，指明方法执行时，可能会抛出的异常类型。如：<code>public void method() throws IOException&#123;&#125;</code>一旦方法体执行时，出现异常，仍会在异常代码的生成处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后面的代码就不再执行！</p>
<p>2.try-catch-finally真正地将异常处理掉了。throws只是将异常抛给了方法的调用者，并没有真正地将异常处理掉。</p>
<p>3.子类重写方法抛出的异常<strong>不能大于父类</strong>被重写方法的<strong>异常</strong>。如如果父类被重写的方法中没有抛出异常，那么子类中重写的方法就不能抛出异常。</p>
<h3 id="7-2-4-异常处理的选择"><a href="#7-2-4-异常处理的选择" class="headerlink" title="7.2.4 异常处理的选择"></a>7.2.4 异常处理的选择</h3><p>1.如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类中重写的方法中有异常，必须使用try-catch-finally方式处理</p>
<p>2.执行的方法中，先后又调用了另外的几个方法，这几个方法是递进关系执行的，那么这几个方法可以使用throws的方式进行处理，而执行的方法可以考虑使用try-catch-finally方式进行处理。</p>
<h2 id="7-3-手动抛出异常：throw"><a href="#7-3-手动抛出异常：throw" class="headerlink" title="7.3 手动抛出异常：throw"></a>7.3 手动抛出异常：throw</h2><p>在“抓抛模型”中，遇到异常自动产生对象的方式有两种：<br>1.系统自动生成异常对象<br>2.手动生成一个异常对象，并抛出（throw）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Student s = <span class="keyword">new</span> Student();</span><br><span class="line">            s.register(-<span class="number">1001</span>);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;<span class="comment">//声明可能出现的异常类型，并给调用者处理</span></span><br><span class="line">        <span class="keyword">if</span> (id &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//            throw new RuntimeException(&quot;您输入的数据非法！&quot;);//运行时报异常，抛出一个RuntimeException异常类的对象</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;您输入的数据非法！&quot;</span>);<span class="comment">//抛出一个Exception异常类的对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210314144658117.png" alt="image-20210314144658117"></p>
<h2 id="7-5-用户自定义异常类"><a href="#7-5-用户自定义异常类" class="headerlink" title="7.5 用户自定义异常类"></a>7.5 用户自定义异常类</h2><p>如何自定义异常类？</p>
<p>1.继承于现有的异常结构：RuntimeException、Exception<br>2.提供全局常量：serialVersionUID<br>3.提供重载的构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7034897190745766939L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomException</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic-blogs.oss-cn-beijing.aliyuncs.com/img/image-20210314155624806.png" alt="image-20210314155624806"></p>
<h1 id="8-多线程"><a href="#8-多线程" class="headerlink" title="8. 多线程"></a>8. 多线程</h1><h2 id="8-1-基本概念：程序、进程、线程"><a href="#8-1-基本概念：程序、进程、线程" class="headerlink" title="8.1 基本概念：程序、进程、线程"></a>8.1 基本概念：程序、进程、线程</h2><blockquote>
<p>程序（program）：就是为了完成特定任务，用某种语言编写的一组指令的集合，即指<strong>一段静态的代码</strong>，静态对象。</p>
<p>进程（process）：就是程序的一次执行过程，或者是<strong>正在运行的一个程序</strong>。是一个动态的过程，有它自身的产生、存在和消亡过程。——生命周期<br>比如：运行中的QQ、微信、视频播放器等。程序是静态的（没有运行的），而进程是动态的（运行的）。<br>此外，进程作为<strong>资源分配的单位</strong>，系统在运行时会为每一个进程分配不同的内存区域。</p>
<p>线程（thread）：进程可进一步细化为线程，是一个程序内部的一条执行路径。<br>若一个进程同一时间并行执行多个线程，那么该进程就是支持多线程的。<br>线程作为<strong>调度和执行的单位</strong>，每个线程都拥有独立的运行栈和程序计数器（PC），线程切换的开销要小。<br>一个进程中的多个线程共享相同的内存单元（堆和方法区）—&gt;它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但是多个线程操作共享的系统资源可能就会带来安全隐患。</p>
</blockquote>
<p>并行：多个 CPU 同时执行多个任务。比如：多个人同时做不同的事</p>
<p>并发：一个 CPU ”同时“（其实是快速切换）执行多个任务。比如：秒杀、多个人做同一件事</p>
<p>以单核 CPU 为例，尽管 CPU 可以并发执行多个线程，但是并发执行本质上是不停地在多个线程之间切换执行，而这个切换时间比较长，所以只使用单个线程先后完成多个任务（调用多个方法），比用多个线程来完成要快。既然如此，为何仍需要多线程？<br>答：1.提高用户体验，比如：多线程执行就能让用户边听音乐边打字；<br>2.提高了CPU的利用率，由于CPU在不停地切换执行线程，没有浪费空闲时间；<br>3.改善程序结构，可以将既长又复杂的进程分为多个线程，独立运行，利于理解和修改。</p>
<p>何时需要多线程？<br>答：1.程序需要同时执行两个或多个任务；<br>2.程序需要实现一些需要等待的任务时，如：用户输入、文件读写操作、网络操作、搜索等；<br>3.需要一些后台运行的程序时。</p>
<h2 id="8-2-线程的创建和使用"><a href="#8-2-线程的创建和使用" class="headerlink" title="8.2 线程的创建和使用"></a>8.2 线程的创建和使用</h2><h2 id="8-3-线程的生命周期"><a href="#8-3-线程的生命周期" class="headerlink" title="8.3 线程的生命周期"></a>8.3 线程的生命周期</h2><h2 id="8-4-线程的同步"><a href="#8-4-线程的同步" class="headerlink" title="8.4 线程的同步"></a>8.4 线程的同步</h2><h2 id="8-5-线程的通信"><a href="#8-5-线程的通信" class="headerlink" title="8.5 线程的通信"></a>8.5 线程的通信</h2><h2 id="8-6-JDK5-0新增线程创建方式"><a href="#8-6-JDK5-0新增线程创建方式" class="headerlink" title="8.6 JDK5.0新增线程创建方式"></a>8.6 JDK5.0新增线程创建方式</h2><h1 id="9-Java常用类"><a href="#9-Java常用类" class="headerlink" title="9. Java常用类"></a>9. Java常用类</h1><h1 id="10-枚举类-amp-注解"><a href="#10-枚举类-amp-注解" class="headerlink" title="10. 枚举类&amp;注解"></a>10. 枚举类&amp;注解</h1><h1 id="11-Java集合"><a href="#11-Java集合" class="headerlink" title="11. Java集合"></a>11. Java集合</h1><h1 id="12-泛型"><a href="#12-泛型" class="headerlink" title="12. 泛型"></a>12. 泛型</h1><h1 id="13-IO流"><a href="#13-IO流" class="headerlink" title="13. IO流"></a>13. IO流</h1><h1 id="14-网络编程"><a href="#14-网络编程" class="headerlink" title="14. 网络编程"></a>14. 网络编程</h1><h1 id="15-Java反射机制"><a href="#15-Java反射机制" class="headerlink" title="15. Java反射机制"></a>15. Java反射机制</h1><p>P389~P405</p>
<p><span id="bottom"></span></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
